{"meta":{"title":"Mearc","subtitle":"博客","description":"一只猪窝","author":"Mearc","url":"https://space.mearc.top","root":"/"},"pages":[{"title":"图库","date":"2022-11-18T01:41:04.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"Gallery/index.html","permalink":"https://space.mearc.top/Gallery/index.html","excerpt":"","text":"壁紙 收藏的一些壁紙 漫威 關於漫威的圖片 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"文章分类","date":"2022-11-18T01:43:02.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"categories/index.html","permalink":"https://space.mearc.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-12-04T08:16:27.811Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"css/custom.css","permalink":"https://space.mearc.top/css/custom.css","excerpt":"","text":"/* @font-face { font-family: Candyhome; src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf); font-display: swap; font-weight: lighter; } */ @font-face { font-family: ZhuZiAYuanJWD; src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2); font-display: swap; font-weight: lighter; } div#menus { font-family: \"ZhuZiAYuanJWD\"; } h1#site-title { font-family: ZhuZiAYuanJWD; font-size: 3em !important; } a.article-title, a.blog-slider__title, a.categoryBar-list-link, h1.post-title { font-family: ZhuZiAYuanJWD; } .iconfont { font-family: \"iconfont\" !important; font-size: 3em; /* 可以定义图标大小 */ font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } /* 时间轴生肖icon */ svg.icon { /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */ width: 1em; height: 1em; /* width和height定义图标的默认宽度和高度*/ vertical-align: -0.15em; fill: currentColor; overflow: hidden; } .icon-zhongbiao::before { color: #f7c768; } /* bilibli番剧插件 */ #article-container .bangumi-tab.bangumi-active { background: var(--anzhiyu-theme); color: var(--anzhiyu-ahoverbg); border-radius: 10px; } a.bangumi-tab:hover { text-decoration: none !important; } .bangumi-button:hover { background: var(--anzhiyu-theme) !important; border-radius: 10px !important; color: var(--anzhiyu-ahoverbg) !important; } a.bangumi-button.bangumi-nextpage:hover { text-decoration: none !important; } .bangumi-button { padding: 5px 10px !important; } a.bangumi-tab { padding: 5px 10px !important; } svg.icon.faa-tada { font-size: 1.1em; } .bangumi-info-item { border-right: 1px solid #f2b94b; } .bangumi-info-item span { color: #f2b94b; } .bangumi-info-item em { color: #f2b94b; } /* 解决artitalk的图标问题 */ #uploadSource > svg { width: 1.19em; height: 1.5em; } /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */ #page-header:not(.not-top-img):before { background-color: transparent !important; } /* 首页文章卡片 */ #recent-posts > .recent-post-item { background: rgba(255, 255, 255, 0.9); } /* 首页侧栏卡片 */ #aside-content .card-widget { background: rgba(255, 255, 255, 0.9); } /* 文章页面正文背景 */ div#post { background: rgba(255, 255, 255, 0.9); } /* 分页页面 */ div#page { background: rgba(255, 255, 255, 0.9); } /* 归档页面 */ div#archive { background: rgba(255, 255, 255, 0.9); } /* 标签页面 */ div#tag { background: rgba(255, 255, 255, 0.9); } /* 分类页面 */ div#category { background: rgba(255, 255, 255, 0.9); } /*夜间模式伪类遮罩层透明*/ [data-theme=\"dark\"] #recent-posts > .recent-post-item { background: #121212; } [data-theme=\"dark\"] .card-widget { background: #121212 !important; } [data-theme=\"dark\"] div#post { background: #121212 !important; } [data-theme=\"dark\"] div#tag { background: #121212 !important; } [data-theme=\"dark\"] div#archive { background: #121212 !important; } [data-theme=\"dark\"] div#page { background: #121212 !important; } [data-theme=\"dark\"] div#category { background: #121212 !important; } [data-theme=\"dark\"] div#category { background: transparent !important; } /* 页脚透明 */ #footer { background: transparent !important; } /* 头图透明 */ #page-header { background: transparent !important; } #rightside > div > button { border-radius: 5px; } /* 滚动条 */ ::-webkit-scrollbar { width: 10px; height: 10px; } ::-webkit-scrollbar-thumb { background-color: #3b70fc; border-radius: 2em; } ::-webkit-scrollbar-corner { background-color: transparent; } ::-moz-selection { color: #fff; background-color: #3b70fc; } /* 音乐播放器 */ /* .aplayer .aplayer-lrc { display: none !important; } */ .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body { left: -66px !important; transition: all 0.3s; /* 默认情况下缩进左侧66px，只留一点箭头部分 */ } .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover { left: 0 !important; transition: all 0.3s; /* 鼠标悬停是左侧缩进归零，完全显示按钮 */ } .aplayer.aplayer-fixed { z-index: 999999 !important; } /* 评论框 */ .vwrap { box-shadow: 2px 2px 5px #bbb; background: rgba(255, 255, 255, 0.3); border-radius: 8px; padding: 30px; margin: 30px 0px 30px 0px; } /* 设置评论框 */ .vcard { box-shadow: 2px 2px 5px #bbb; background: rgba(255, 255, 255, 0.3); border-radius: 8px; padding: 30px; margin: 30px 0px 0px 0px; } /* 鼠标图标 */ body { cursor: url(\"/img/x1.cur\"), auto; } a, [type=\"button\"]:not(:disabled), [type=\"reset\"]:not(:disabled), [type=\"submit\"]:not(:disabled), button:not(:disabled) { cursor: url(\"/img/x2.cur\"), auto !important; } /* md网站下划线 */ #article-container a:hover { text-decoration: none !important; } #article-container #hpp_talk p img { display: inline; } /* 404页面 */ #error-wrap { position: absolute; top: 40%; right: 0; left: 0; margin: 0 auto; padding: 0 1rem; max-width: 1000px; transform: translate(0, -50%); } #error-wrap .error-content { display: flex; flex-direction: row; justify-content: center; align-items: center; margin: 0 1rem; height: 18rem; border-radius: 8px; background: var(--card-bg); box-shadow: var(--card-box-shadow); transition: all 0.3s; } #error-wrap .error-content .error-img { box-flex: 1; flex: 1; height: 100%; border-top-left-radius: 8px; border-bottom-left-radius: 8px; background-color: #3b70fc; background-position: center; background-size: cover; } #error-wrap .error-content .error-info { box-flex: 1; flex: 1; padding: 0.5rem; text-align: center; font-size: 14px; font-family: Titillium Web, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft JhengHei\", \"Microsoft YaHei\", sans-serif; } #error-wrap .error-content .error-info .error_title { margin-top: -4rem; font-size: 9em; } #error-wrap .error-content .error-info .error_subtitle { margin-top: -3.5rem; word-break: break-word; font-size: 1.6em; } #error-wrap .error-content .error-info a { display: inline-block; margin-top: 0.5rem; padding: 0.3rem 1.5rem; background: var(--btn-bg); color: var(--btn-color); } #body-wrap.error .aside-list { display: flex; flex-direction: row; flex-wrap: nowrap; bottom: 0px; position: absolute; padding: 1rem; width: 100%; overflow: scroll; } #body-wrap.error .aside-list .aside-list-group { display: flex; flex-direction: row; flex-wrap: nowrap; max-width: 1200px; margin: 0 auto; } #body-wrap.error .aside-list .aside-list-item { padding: 0.5rem; } #body-wrap.error .aside-list .aside-list-item img { width: 100%; object-fit: cover; border-radius: 12px; } #body-wrap.error .aside-list .aside-list-item .thumbnail { overflow: hidden; width: 230px; height: 143px; background: var(--anzhiyu-card-bg); display: flex; } #body-wrap.error .aside-list .aside-list-item .content .title { -webkit-line-clamp: 2; overflow: hidden; display: -webkit-box; -webkit-box-orient: vertical; line-height: 1.5; justify-content: center; align-items: flex-end; align-content: center; padding-top: 0.5rem; color: white; } #body-wrap.error .aside-list .aside-list-item .content time { display: none; } /* 代码框主题 */ #article-container figure.highlight { border-radius: 10px; }"},{"title":"关于","date":"2022-11-18T01:24:48.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"about/index.html","permalink":"https://space.mearc.top/about/index.html","excerpt":"","text":"不知道写什么，反正就是一些乱七八糟的记录"},{"title":"链接","date":"2022-11-27T06:46:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"link/index.html","permalink":"https://space.mearc.top/link/index.html","excerpt":"","text":"论坛有很多值得学习 博客园 代码改变世界 菜鸟教程 学的不仅是技术，更是梦想 GitHub 全球最大的开源网站 图标免费开源的图标网站 IconFont 阿里巴巴旗下图标库 iconpark 字节跳动旗下图标库 寻标网 图标分享平台"},{"title":"小短片","date":"2022-11-18T01:43:23.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"movies/index.html","permalink":"https://space.mearc.top/movies/index.html","excerpt":"","text":"《喜欢》- 阿巳与小铃铛(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#efefef\",\"loop\":true,\"video\":{\"url\":\"https://space.mearc.top:6850/video/asihexiaolingdang.flv\",\"pic\":\"https://ts1.cn.mm.bing.net/th/id/R-C.cdb0096c44f5faa661cc51d209dda9e9?rik=o0i%2f7DURkx24%2bw&riu=http%3a%2f%2fwww.shcaoan.com%2fwy%2fpic1%2f202101%2f20210129113207527.jpg&ehk=quiMZXW3PJ0UUwe4TPAS%2bXViEYxXyav1OXnlM%2faFz2c%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() -转载BiliBili-阿巳与小铃铛 《可能》- 李怡然同学(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"theme\":\"#efefef\",\"loop\":true,\"video\":{\"url\":\"https://space.mearc.top:6850/video/%E5%8F%AF%E8%83%BD-%E6%9D%8E%E6%80%A1%E7%84%B6%E5%90%8C%E5%AD%A6.mp4\",\"pic\":\"https://pic.jitapai.com/wp-content/uploads/2022/10/2022101107263431.jpeg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() -来至酷狗音乐 《偷猎者》- 哔哩哔哩"},{"title":"音乐推荐","date":"2022-11-18T01:40:22.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"music/index.html","permalink":"https://space.mearc.top/music/index.html","excerpt":"","text":"var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"可能\",\"author\":\"李怡然同学\",\"url\":\"https://space.mearc.top:6850/music/liyiran/%E5%8F%AF%E8%83%BD-%E6%9D%8E%E6%80%A1%E7%84%B6%E5%90%8C%E5%AD%A6.flac\",\"pic\":\"https://imgessl.kugou.com/stdmusic/20221121/20221121183855904908.jpg\",\"lrc\":\"https://space.mearc.top:6850/music/liyiran/%E5%8F%AF%E8%83%BD-%E6%9D%8E%E6%80%A1%E7%84%B6%E5%90%8C%E5%AD%A6.lrc\"},{\"title\":\"不能说的秘密\",\"author\":\"周杰伦\",\"url\":\"https://space.mearc.top:6850/music/zhoujl/F000000cZNr42YkLl1.flac\",\"pic\":\"https://imgessl.kugou.com/uploadpic/softhead/240/20220714/20220714130853543.jpg\",\"lrc\":\"https://cn-south-17-aplayer-46154810.oss.dogecdn.com/hikarunara.lrc\"},{\"title\":\"七里香\",\"author\":\"周杰伦\",\"url\":\"https://space.mearc.top:6850/music/zhoujl/F0000012Ez0a1tFcOI.flac\",\"pic\":\"https://imgessl.kugou.com/uploadpic/softhead/240/20220714/20220714130853543.jpg\",\"lrc\":\"https://cn-south-17-aplayer-46154810.oss.dogecdn.com/hikarunara.lrc\"},{\"title\":\"说好的幸福呢\",\"author\":\"周杰伦\",\"url\":\"https://space.mearc.top:6850/music/zhoujl/F000001a8tgu4DggDy.flac\",\"pic\":\"https://imgessl.kugou.com/uploadpic/softhead/240/20220714/20220714130853543.jpg\",\"lrc\":\"https://cn-south-17-aplayer-46154810.oss.dogecdn.com/hikarunara.lrc\"},{\"title\":\"稻香\",\"author\":\"周杰伦\",\"url\":\"https://space.mearc.top:6850/music/zhoujl/F0000020wJDo3cx0j3.flac\",\"pic\":\"https://imgessl.kugou.com/uploadpic/softhead/240/20220714/20220714130853543.jpg\",\"lrc\":\"https://cn-south-17-aplayer-46154810.oss.dogecdn.com/hikarunara.lrc\"},{\"title\":\"晴天\",\"author\":\"周杰伦\",\"url\":\"https://space.mearc.top:6850/music/zhoujl/F000002202B43Cq4V4.flac\",\"pic\":\"https://imgessl.kugou.com/uploadpic/softhead/240/20220714/20220714130853543.jpg\",\"lrc\":\"https://cn-south-17-aplayer-46154810.oss.dogecdn.com/hikarunara.lrc\"},{\"title\":\"夜曲\",\"author\":\"周杰伦\",\"url\":\"https://space.mearc.top:6850/music/zhoujl/F0000024jrso28p8VA.flac\",\"pic\":\"https://imgessl.kugou.com/uploadpic/softhead/240/20220714/20220714130853543.jpg\",\"lrc\":\"https://cn-south-17-aplayer-46154810.oss.dogecdn.com/hikarunara.lrc\"},{\"title\":\"发如雪\",\"author\":\"周杰伦\",\"url\":\"https://space.mearc.top:6850/music/zhoujl/F000002A6j2q1tdUUP.flac\",\"pic\":\"https://imgessl.kugou.com/uploadpic/softhead/240/20220714/20220714130853543.jpg\",\"lrc\":\"https://cn-south-17-aplayer-46154810.oss.dogecdn.com/hikarunara.lrc\"},{\"title\":\"超人不会飞\",\"author\":\"周杰伦\",\"url\":\"https://space.mearc.top:6850/music/zhoujl/F000002TTsgm1Kfw6G.flac\",\"pic\":\"https://imgessl.kugou.com/uploadpic/softhead/240/20220714/20220714130853543.jpg\",\"lrc\":\"https://cn-south-17-aplayer-46154810.oss.dogecdn.com/hikarunara.lrc\"},{\"title\":\"告白气球\",\"author\":\"周杰伦\",\"url\":\"https://space.mearc.top:6850/music/zhoujl/F0000043HkiY0CMwVm.flac\",\"pic\":\"https://imgessl.kugou.com/uploadpic/softhead/240/20220714/20220714130853543.jpg\",\"lrc\":\"https://cn-south-17-aplayer-46154810.oss.dogecdn.com/hikarunara.lrc\"}]}; options.element = document.getElementById(\"aplayer-ccrfAJgT\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"标签","date":"2022-11-18T01:42:43.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"tags/index.html","permalink":"https://space.mearc.top/tags/index.html","excerpt":"","text":""},{"title":"3D旋转词云","date":"2022-11-18T01:43:23.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"wenxiu/index.html","permalink":"https://space.mearc.top/wenxiu/index.html","excerpt":"","text":""},{"title":"图库演示","date":"2022-11-26T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"Gallery/wallpaper/index.html","permalink":"https://space.mearc.top/Gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"ODA简单入门","slug":"ODA-dwg","date":"2023-01-05T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2023/01/06/ODA-dwg/","link":"","permalink":"https://space.mearc.top/2023/01/06/ODA-dwg/","excerpt":"","text":"DWG文件数据结构","categories":[{"name":"ODA","slug":"ODA","permalink":"https://space.mearc.top/categories/ODA/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"}]},{"title":"Qt常见宏定义","slug":"Qt-MacroDefinition","date":"2023-01-01T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2023/01/02/Qt-MacroDefinition/","link":"","permalink":"https://space.mearc.top/2023/01/02/Qt-MacroDefinition/","excerpt":"","text":"Qt常见宏定义Q_OBJECT：继承了QObject类的类，使其具有信号槽的能力。&emsp;&emsp;QObject 是Qt模块的核心。它的最主要特征是关于对象间无缝通信的机制：信号与槽。使用connect()建立信号到槽的连接，使用disconnect()销毁连接，使用blockSignals()暂时阻塞信号以避免无限通知循环，使用connectNotify()和disconnectNotify()追踪连接。&emsp;&emsp;使用信号槽，必须直接或间接继承QObject，都应该在第一行代码写上Q_OBJECT。不管是不是使用信号槽，都应该添加这个宏。这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力。因此，如果你觉得你的类不需要使用信号槽，就不添加这个宏，就是错误的。其它很多操作都会依赖于这个宏。示例： 123456789#include &lt;QObject&gt;class xx ：public QObject&#123; Q_OBJECTpublic: xx(QObject* parent ); ~xx()&#125; 常见系统宏定义Q_OS_MAC：Mac系统宏定义Q_OS_WIN：Windoows(x86/x64)系统宏定义Q_OS_WIN32：Windoows(x86/x64)系统宏定义Q_OS_WIN64：Windoows(x64)系统宏定义Q_OS_ANDROID：Android系统宏定义Q_OS_LINUX：liunx系统宏定义 示例： 1234567#if defined(Q_OS_WIN32) qDebug()&lt;&lt;&quot;Q_OS_WIN32&quot;;#elif defined(Q_OS_LINUX) qDebug()&lt;&lt;&quot;Q_OS_LINUX&quot;;#else qDebug()&lt;&lt;&quot;Q_OS_other&quot;;#endif 虚函数宏定义Q_DECL_OVERRIDE：防止虚函数重写不正确 12void paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const Q_DECL_OVERRIDE; 取消警告Q_UNUSED（index）: 取消没有使用的变量警告 12345 void paint(int index ,int abc)&#123; Q_UNUSED（index） int c = abc;&#125; 国际化 Q_DECLARE_TR_FUNCTIONS(what) : 给非Qt类添加翻译支持 1234struct Tr&#123; Q_DECLARE_TR_FUNCTIONS(Welcome)&#125;; QT_TR_NOOP() 和QT_TRANSLATE_NOOP() :翻译的文本在函数的外部 QT_TR_NOOP() 示例 12345678QString FriendlyConversation::greeting(int type)&#123; staticconst char *greeting_strings[]= &#123; QT_TR_NOOP(&quot;Hello&quot;), QT_TR_NOOP(&quot;Goodbye&quot;) &#125;; return tr(greeting_strings[type]);&#125; QT_TRANSLATE_NOOP() 示例 12345678910111213141516staticconst char *greeting_strings[]= &#123; QT_TRANSLATE_NOOP(&quot;FriendlyConversation&quot;,&quot;Hello&quot;), QT_TRANSLATE_NOOP(&quot;FriendlyConversation&quot;,&quot;Goodbye&quot;)&#125;; QString FriendlyConversation::greeting(int type)&#123; return tr(greeting_strings[type]);&#125; QString global_greeting(int type)&#123; return qApp-&gt;translate(&quot;FriendlyConversation&quot;, greeting_strings[type]);&#125; PS：如果你用宏QT_NO_CAST_FROM_ASCII定义来编译软件禁止从const char * 到Qstring 的转换，你就可能捕获任何漏掉的字符串。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://space.mearc.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://space.mearc.top/tags/Qt/"}]},{"title":"策略模式","slug":"DesignPatterns-StrategyPattern","date":"2022-12-27T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/28/DesignPatterns-StrategyPattern/","link":"","permalink":"https://space.mearc.top/2022/12/28/DesignPatterns-StrategyPattern/","excerpt":"","text":"动机完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。 定义策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 策略模式是一种对象行为型模式。 结构策略模式包含如下角色： Context: 环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 各国的税率计算示例// 税率计算基类class TaxStrategy&#123; virtual double Calculate(const Context&amp; context) = 0; virtual ~TaxStrategy()&#123;&#125;;&#125;;// 中国的税法计算class CNTax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context) &#123; // .... &#125;&#125;;// 美国的税法计算class USTax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context) &#123; // .... &#125;&#125;;// 德国的税法计算class DETax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context) &#123; // .... &#125;&#125;;/*......等等.......*/// 计算税率的规则class SalesOrder&#123;private: TaxStrategy* m_taxStrategy; public: SalesOrder(StrategyFactory* strategyFactory) &#123; this-&gt;m_taxStrategy = strategyFactory-&gt;NewStrategy(); // 使用工厂模式生成需要使用的税率计算对象 &#125; ~SalesOrder()&#123;&#125;; double CalculateTax() &#123; // ... Context context(); double val = m_taxStrategy-&gt;Calculate(context); // 多态调用 //... return val; &#125;&#125;; 总结Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"}]},{"title":"设计原则","slug":"DesignPatterns-designPrinciple","date":"2022-12-27T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/28/DesignPatterns-designPrinciple/","link":"","permalink":"https://space.mearc.top/2022/12/28/DesignPatterns-designPrinciple/","excerpt":"","text":"六大设计原则主要是指： 单一职责原则（Single Responsibility Principle）； 开闭原则（Open Closed Principle）； 里氏替换原则（Liskov Substitution Principle）； 迪米特法则（Law of Demeter），又叫“最少知道法则”； 接口隔离原则（Interface Segregation Principle）； 依赖倒置原则（Dependence Inversion Principle）。 单一职责原则定义：一个类应该只有一个发生变化的原因 那这个原则有什么用呢，它让类的职责更单一。这样的话，每个类只需要负责自己的那部分，类的复杂度就会降低。如果职责划分得很清楚，那么代码维护起来也更加容易。试想如果所有的功能都放在了一个类中，那么这个类就会变得非常臃肿，而且一旦出现bug，要在所有代码中去寻找；更改某一个地方，可能要改变整个代码的结构，想想都非常可怕。当然一般时候，没有人会去这么写的。 当然，这个原则不仅仅适用于类，对于接口和方法也适用，即一个接口/方法，只负责一件事，这样的话，接口就会变得简单，方法中的代码也会更少，易读，便于维护。 事实上，由于一些其他的因素影响，类的单一职责在项目中是很难保证的。通常，接口和方法的单一职责更容易实现。 单一原则的好处：代码的粒度降低了，类的复杂度降低了。可读性提高了，每个类的职责都很明确，可读性自然更好。可维护性提高了，可读性提高了，一旦出现 bug ，自然更容易找到他问题所在。改动代码所消耗的资源降低了，更改的风险也降低了。 开闭原则定义：一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭 那么开闭原则具体是什么呢？可以说，开闭原则贯穿于以上五个设计模式原则。开闭原则中的对扩展开放，就是说，如果在项目中添加一个功能的时候，可以直接对代码进行扩展；如果要修改某一部分的功能时，我们应该做的是，尽量少做修改（完全不修改是不可能的），但是修改的时候，要保留原来的功能，只是在上面扩展出新的功能，就像版本更新一样，更新后，依然支持旧版本。 里氏替换原则定义：所有引用基类的地方必须能透明地使用其子类的对象 里氏替换原则的意思是，所有基类在的地方，都可以换成子类，程序还可以正常运行。这个原则是与面向对象语言的 继承 特性密切相关的。 这是为什么呢？由于面向对象语言的继承特性，子类拥有父类的所有方法，因此，将基类替换成具体的子类，子类也可以调用父类中的方法（其实是它自己的方法，继承于父类），但是如果要保证完全可以调用，光名称相同不行，还需要满足下面两个条件： 子类中的方法的前置条件必须与超类中被覆写的方法的前置条件相同或更宽松。 子类中的方法的后置条件必须与超类中被覆写的方法的后置条件相同或更严格。 这样的话，调用就没有问题了。否则，我在父类中传入一个 List 类型的参数，子类中重写的方法参数却变为 ArrayList ，那客户端使用的时候传入一个 LinkedList 类型的参数，使用父类的时候程序正常运行，但根据 LSP 原则，替换成子类后程序就会出现问题。同理，后置条件也是如此。 迪米特法则定义：迪米特法则（LoD）也叫最少知道法则：一个对象应该对其他对象有最少的了解。 这个原则也没什么需要多讲的，调用者只需要知道被调用者公开的方法就好了，至于它内部是怎么实现的或是有其他别的方法，调用者并不关心，调用者只关心它需要用的。反而，如果被调用者暴露太多不需要暴露的属性或方法，那么就可能导致调用者滥用其中的方法，或是引起一些其他不必要的麻烦。 接口隔离原则定义：1、客户端不应该依赖它不需要的接口。2、类间的依赖关系应该建立在最小的接口上 这是什么意思呢，这是让我们把接口进行细分。举个例子，如果一个类实现一个接口，但这个接口中有它不需要的方法，那么就需要把这个接口拆分，把它需要的方法提取出来，组成一个新的接口让这个类去实现，这就是接口隔离原则。简而言之，就是说，接口中的所有方法对其实现的子类都是有用的。否则，就将接口继续细分。 看起来，该原则与单一职责原则很相像。确实很像，二者都是强调要将接口进行细分，只不过分的方式不同。单一职责原则是按照 职责 进行划分接口的；而接口隔离原则则是按照实现类对方法的使用来划分的。可以说，接口隔离原则更细一些。 要想完美地实现该原则，基本上就需要每个实现类都有一个专用的接口。但实际开发中，这样显然是不可能的，而且，这样很容易违背单一职责原则（可能出现同一个职责分成了好几个接口的情况），因此我们能做的就是尽量细分。 该原则主要强调两点： 接口尽量小。 就像前面说的那样，接口中只有实现类中有用的方法。 接口要高内聚 就是说，在接口内部实现的方法，不管怎么改，都不会影响到接口外的其他接口或是实现类，只能影响它自己。 依赖倒置原则定义：1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。2、抽象不应该依赖于细节，细节应该依赖于抽象。 解释： 高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节。细节应该依赖抽象。 在Java语言中的表现就是： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。接口或抽象类不依赖于实现类。实现类依赖于接口或抽象类。简而言之，我们要尽可能使用接口或抽象类。也就是“面向接口编程” 或者说 “面向抽象编程” ，也就是说程序中要尽可能使用抽象类或是接口。 参考链接维基百科：https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1) CSDN：https://blog.csdn.net/rocketeerli/article/details/81585705 知乎：https://zhuanlan.zhihu.com/p/110130347","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"}]},{"title":"模板方法（Template Method）","slug":"DesignPatterns-templateMethod","date":"2022-12-27T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/28/DesignPatterns-templateMethod/","link":"","permalink":"https://space.mearc.top/2022/12/28/DesignPatterns-templateMethod/","excerpt":"","text":"动机在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很做变的需求，或者由于固有的原因(比如框架与应用之间的关系)而无法和任务的整体结构同时实现。 定义定义一个操作中的算法的骨架（稳定），而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override重写)该算法的某些特定步骤。 结构 未使用模板方法的示例： 结构化软件设计流程 123456789101112131415161718192021222324252627282930313233343536373839// 某开发人员开发的lib库class lib&#123; public: void step1()&#123;&#125;; void step3()&#123;&#125;; void step5()&#123;&#125;;&#125;// 某开发人员开发的应用class app&#123; public: bool step2()&#123;&#125;; void step4()&#123;&#125;;&#125;// 主程序int main()&#123; // 程序主流程 lib mylib; app myapp; mylib.step1(); if(myapp.step2()) &#123; mylib.step3(); &#125; for(int i=0; i&lt;2;i++) &#123; myapp.step4(); &#125; mylib.step5();&#125; 使用模板方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 某开发人员开发的lib库class lib&#123; public: void run()&#123; // 程序主流程 step1(); if(step2()) // 支持变化 ==&gt; 虚函数的多态调用 &#123; step3(); &#125; for(int i=0; i&lt;2;i++) &#123; step4(); // 支持变化 ==&gt; 虚函数的多态调用 &#125; step5(); &#125;; void step1()&#123;&#125;; void step3()&#123;&#125;; void step5()&#123;&#125;; virtual bool step2() = 0; virtual void step4() = 0; virtual ~lib()&#123;&#125;; // 不加的话，子类无法析构 &#125;// 某开发人员开发的应用class app :public lib&#123; public: bool step2()&#123;&#125;; // 重写要执行的操作 void step4()&#123;&#125;; // 重写要执行的操作&#125;// 主程序int main()&#123; lib* mylib = new app(); mylib.run();&#125; 总结： Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。在具体实现方面，被Template Method调用的虚方法可以有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般它们设置为protected方法。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"}]},{"title":"建造者模式","slug":"DesignPatterns-builder","date":"2022-12-21T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/22/DesignPatterns-builder/","link":"","permalink":"https://space.mearc.top/2022/12/22/DesignPatterns-builder/","excerpt":"","text":"定义造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。 结构建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 抽奖建造者class Builder&#123;public: Builder()&#123;&#125;;&#125;;// 具体建筑者class ConcreteBuilder : public Builder&#123;public: ConcreteBuilder()&#123;&#125;; void buildPartA()&#123; m_prod-&gt;setA(&quot;A Style &quot;); //不同的建造者，可以实现不同产品的建造 &#125; void :buildPartB()&#123; m_prod-&gt;setB(&quot;B Style &quot;);&#125; void buildPartC()&#123; m_prod-&gt;setC(&quot;C style &quot;);&#125;&#125;;// 指挥者class Director&#123;public: Director()&#123;&#125;; Product* constuct()&#123; m_pbuilder-&gt;buildPartA(); m_pbuilder-&gt;buildPartB(); m_pbuilder-&gt;buildPartC(); return m_pbuilder-&gt;getResult();&#125; void setBuilder(Builder* buider)&#123; m_pbuilder = buider;&#125;private： Builder* m_pbuilder;&#125;; // 主函数int main(int argc, char *argv[])&#123; ConcreteBuilder * builder = new ConcreteBuilder(); Director director; director.setBuilder(builder); Product * pd = director.constuct(); pd-&gt;show(); delete builder; delete pd; return 0;&#125; 在以下情况下可以使用建造者模式： 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 总结 建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。 建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造 在建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。 参考资料：https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/builder.html","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂模式","slug":"DesignPatterns-abstract_factory","date":"2022-12-20T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/21/DesignPatterns-abstract_factory/","link":"","permalink":"https://space.mearc.top/2022/12/21/DesignPatterns-abstract_factory/","excerpt":"","text":"定义抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 结构 抽象工厂模式包含如下角色： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 抽象产品Aclass AbstractFactoryA&#123; AbstractFactoryA()&#123;&#125;;&#125;;// 产品A1class ProductA1 : public AbstractFactoryA&#123; ProductA1()&#123;&#125;;&#125;;// 产品A2class ProductA2 : public AbstractFactoryA&#123; ProductA2()&#123;&#125;;&#125;;// 抽象产品Bclass AbstractFactoryB&#123; AbstractFactoryA()&#123;&#125;;&#125;;// 产品B1class ProductB1 : public AbstractFactoryB&#123; ProductB1()&#123;&#125;;&#125;;// 产品B2class ProductB2 : public AbstractFactoryB&#123; ProductB2()&#123;&#125;;&#125;;// 抽象工厂class AbstractFactory&#123; Factory()&#123;&#125;;&#125;;// 工厂1class ConcreteFactory1 : public AbstractFactory&#123;public: ConcreteFactory1()&#123;&#125;; AbstractFactoryA* createProductA()&#123; return new ProductA1(); AbstractFactoryB* createProductB()&#123; return new ProductB1();&#125;; // 工厂2class ConcreteFactory2 : public AbstractFactory&#123;public: ConcreteFactory2()&#123;&#125;; AbstractFactoryA* createProductA()&#123; return new ProductA1(); AbstractFactoryB* createProductB()&#123; return new ProductB1();&#125;; // 主函数int main(int argc, char *argv[])&#123; AbstractFactory * fc = new ConcreteFactory1(); AbstractProductA * pa = fc-&gt;createProductA(); AbstractProductB * pb = fc-&gt;createProductB(); AbstractFactory * fc2 = new ConcreteFactory2(); AbstractProductA * pa2 = fc2-&gt;createProductA(); AbstractProductB * pb2 = fc2-&gt;createProductB(); delete fc; delete pa; delete pb; delete fc2; delete pa2; delete pb2; return 0;&#125; 总结 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 抽象工厂模式包含四个角色：抽象工厂用于声明生成抽象产品的方法；具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。 抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。 抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 参考资料：https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂模式","slug":"DesignPatterns-factory_method","date":"2022-12-20T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/21/DesignPatterns-factory_method/","link":"","permalink":"https://space.mearc.top/2022/12/21/DesignPatterns-factory_method/","excerpt":"","text":"定义工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 结构工厂方法模式包含如下角色： Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂 代码示例： 12345678910111213141516171819202122232425// 抽象工厂class Factory&#123; Factory()&#123;&#125;;&#125;// 工厂class ConcreteFactory : public Factory&#123;public: ConcreteFactory()&#123;&#125;; Product* createProduct()&#123; return new ConcreteProduct();&#125;; // 主函数int main(int argc, char *argv[])&#123; Factory* f = new ConcreteFactory(); Product* p = f-&gt;createProduct() p-&gt;use(); delete f; delete p; return 0;&#125; 总结优点 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。 参考资料：https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"简单工厂模式","slug":"DesignPatterns-simple_factory","date":"2022-12-20T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/21/DesignPatterns-simple_factory/","link":"","permalink":"https://space.mearc.top/2022/12/21/DesignPatterns-simple_factory/","excerpt":"","text":"定义简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 结构简单工厂模式包含如下角色： Factory：工厂角色 工厂角色负责实现创建所有实例的内部逻辑 Product：抽象产品角色 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreteProduct：具体产品角色 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 抽象产品class Product&#123;public: Product()&#123;&#125;;&#125;;// 产品Aclass A : public Product&#123;public: A()&#123;&#125;;&#125;;// 产品Bclass B : public Product&#123;public: B()&#123;&#125;;&#125;;// 工厂class Factory&#123;public: Factory()&#123;&#125;; Product* createProduct(String proname)&#123; if ( &quot;A&quot; == proname ) &#123; return new A(); &#125; else if(&quot;B&quot; == proname) &#123; return new B(); &#125; return NULL;&#125;; // 主函数int main(int argc, char *argv[])&#123; Factory w; Product* p = w.createProduct(&quot;A&quot;) p-&gt;use(); delete p; return 0;&#125; 总结 创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。 简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。 参考资料：https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"DesignPatterns-singleton","date":"2022-12-20T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/21/DesignPatterns-singleton/","link":"","permalink":"https://space.mearc.top/2022/12/21/DesignPatterns-singleton/","excerpt":"","text":"定义单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。 结构 单例模式包含如下角色： Singleton：单例 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 单例模式一：懒汉式（线程不安全，使用时创建） 示例： 123456789101112131415161718192021222324252627class QSingleton&#123;public: static QSingleton* instance() &#123; if (m_pInstance == NULL) m_pInstance = new QSingleton(); return m_pInstance; &#125; static void Release() &#123; if (m_pInstance != NULL) &#123; delete m_pInstance; m_pInstance = NULL; &#125; &#125;private: QSingleton()&#123;&#125; QSingleton(const QSingleton&amp;)&#123;&#125; QSingleton&amp; operator==(const QSingleton&amp;)&#123;&#125;private: static QSingleton* m_pInstance;&#125;;// 静态成员变量需要在类体的外面进行初始化QSingleton* QSingleton::m_pInstance = NULL; 缺点： 每次都得判断m_pInstance是否为空，增加了程序开销，而饿汉模式没有此问题。 需要手动调用Release函数释放静态成员变量分配内存，上面的饿汉模式也有此问题。针对此问题我们可以通过智能指针来避免。 不是线程安全的，要想在多线程环境下安全使用，就需要在程序一开始处，其他线程还未创建时，调用一次instance函数，但这样就抛弃了懒汉模式延迟加载的优点。饿汉模式因为在程序一开始就创建了对象，因此是线程安全的。 单例模式二：饿汉式（线程安全，main之前创建，用不用都提前创建）示例： 123456789101112131415161718192021222324252627class QSingleton&#123;public: static QSingleton* instance() &#123; return m_pInstance; &#125; static void Release() &#123; if (m_pInstance != NULL) &#123; delete m_pInstance; m_pInstance = NULL; &#125; &#125; QSingleton()&#123;&#125;private: QSingleton(const QSingleton&amp;)&#123;&#125; QSingleton&amp; operator==(const QSingleton&amp;)&#123;&#125;private: static QSingleton* m_pInstance;&#125;;// 直接初始化静态成员变量QSingleton* QSingleton::m_pInstance = new QSingleton; 缺点：1.内存消耗 单例模式三：通过智能指针管理（线程安全 通过加锁保证了m_pInstance创建的唯一性） 示例： 1234567891011121314151617181920212223class QSingleton&#123;public: static QSharedPointer&lt;QSingleton&gt;&amp; instance() &#123; QMutexLocker mutexLocker(&amp;m_Mutex); if (m_pInstance.isNull()) &#123; m_pInstance = QSharedPointer&lt;QSingleton&gt;(new QSingleton()); &#125; return m_instance; &#125;private: QSingleton()&#123;&#125; QSingleton(const QSingleton&amp;)&#123;&#125; QSingleton&amp; operator==(const QSingleton&amp;)&#123;&#125;private: static QMutex m_Mutex; static QSharedPointer&lt;QSingleton&gt; m_pInstance;&#125;;QMutex QSingleton::m_Mutex;QSharedPointer&lt;QSingleton&gt; QSingleton::m_pInstance; 缺点：通过智能指针来管理成员变量，保证了在程序退出时，自动释放内存，通过加锁保证了m_pInstance创建的唯一性，但是因为程序每次调用instance就需要先加锁，大大增加了程序开销 改进： 123456789101112131415161718192021222324class QSingleton&#123;public: static QSharedPointer&lt;QSingleton&gt;&amp; instance() &#123; if (m_pInstance.isNull()) &#123; QMutexLocker mutexLocker(&amp;m_Mutex); if (m_pInstance.isNull()) m_pInstance = QSharedPointer&lt;QSingleton&gt;(new QSingleton()); &#125; return m_pInstance; &#125;private: QSingleton()&#123;&#125; QSingleton(const QSingleton&amp;)&#123;&#125; QSingleton&amp; operator==(const QSingleton&amp;)&#123;&#125;private: static QMutex m_Mutex; static QSharedPointer&lt;QSingleton&gt; m_pInstance;&#125;;QMutex QSingleton::m_Mutex;QSharedPointer&lt;QSingleton&gt; QSingleton::m_pInstance; 单例模式四：Meyers模式（线程不安全）示例： 12345678910111213class QSingleton&#123;public: static QSingleton&amp; instance() &#123; static QSingleton qinstance; return qinstance; &#125;private: QSingleton()&#123;&#125; QSingleton(const QSingleton&amp;)&#123;&#125; QSingleton&amp; operator==(const QSingleton&amp;)&#123;&#125;&#125;; 总结 单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。 单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。 单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。 单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。 单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。 参考资料：https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Nginx 安装","slug":"NginxInstall","date":"2022-12-19T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/20/NginxInstall/","link":"","permalink":"https://space.mearc.top/2022/12/20/NginxInstall/","excerpt":"","text":"安装安装地址：https://nginx.org/en/download.html Windows: 解压即可 Liunx: 1apt-get install nginx 常见命令: 查看常见的命令:service nginx 启动： service nginx start 停止： service nginx stop 重启：service nginx restart 静态资源服务示例：配置文件位置(一般位置，不同版本稍有不同)： windows: 安装路径下/conf/nginx.conf Liunx: /etc/nginx/conf/nginx.conf 1234567891011121314151617 server &#123; listen 80; server_name space.mearc.top; charset utf-8; location / &#123; root C:/abc; index index.html index.htm; autoindex on; &#125;&#125; Http转Https示例： 12345server &#123; listen 80; server_name space.mearc.top; rewrite ^(.*)$ https://$host$1 permanent;&#125; SSL示例： 1234567891011121314server&#123; listen 443 ssl; listen space.mearc.top; server_name space.mearc.top; ssl on; ssl_certificate space.mearc.top_bundle.crt; ssl_certificate_key space.mearc.top.key; location / &#123; index index.html index.htm; root /usr/share/nginx/wxres; autoindex on; &#125;&#125;","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://space.mearc.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://space.mearc.top/tags/nginx/"}]},{"title":"Qt QSS 基本用法","slug":"Qt-qss","date":"2022-12-19T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/20/Qt-qss/","link":"","permalink":"https://space.mearc.top/2022/12/20/Qt-qss/","excerpt":"","text":"QSS设置 官方文档：Qt Style Sheets Reference优点：可以快速方便的对Ui界面的样式做更改；缺点：对于高分屏优化比较差，会造成模糊，大小不一致等问题；可是重写QStyle解决该问题，QStyle能更开放房的个性化定制，实现更加高级的功能； 全局加载方法 将.qss文件加入资源文件 main.cpp 中加入示例： 123456789101112131415161718#include &lt;QtWidgets/QApplication&gt;#include &lt;QFile&gt; int main(int argc, char *argv[])&#123; QApplication a(argc, argv); // 加载qss文件 QFile qssFlie(&quot;:/Default.qss&quot;); if (qssFlie.open(QIODevice::ReadOnly)) &#123; QString style = qssFlie.readAll(); a-&gt;setStyleSheet(style); qssFlie.close(); &#125; w.show(); return a.exec();&#125; 单个控件设置方法：示例： 123QPushButton* but = new QPushButton(this);but-&gt;setStyleSheet(&quot;QPushButton&#123;background-color: transparent;padding:5px,5px,5px,5px;text-align:left;&#125;QPushButton:hover&#123;border-bottom:2px solid #079a18;border-radius:0px; &#125;QPushButton:pressed&#123;border-bottom:2px solid #5c940d;&#125;&quot;); QSS基本属性设置Qss的强大在于组合功能的强大，这里只是简单介绍基本功能，将简单功能组合起来才能实现好看的效果。 QSS背景属性（Background）属性描述CSSbackground在一个声明中设置所有的背景属性。1background-attachment设置背景图像是否固定或者随着页面的其余部分滚动。1background-color设置元素的背景颜色。1background-image设置元素的背景图像。1background-position设置背景图像的开始位置。1background-repeat设置是否及如何重复背景图像。1background-clip规定背景的绘制区域。3background-origin规定背景图片的定位区域。3background-size规定背景图片的尺寸。3 QSS边框属性（Border和 Outline）属性描述CSSborder在一个声明中设置所有的边框属性。1border-bottom在一个声明中设置所有的下边框属性。1border-bottom-color设置下边框的颜色。2border-bottom-style设置下边框的样式。2border-bottom-width设置下边框的宽度。1border-color设置四条边框的颜色。1border-left在一个声明中设置所有的左边框属性。1border-left-color设置左边框的颜色。2border-left-style设置左边框的样式。2border-left-width设置左边框的宽度。1border-right在一个声明中设置所有的右边框属性。1border-right-color设置右边框的颜色。2border-right-style设置右边框的样式。2border-right-width设置右边框的宽度。1border-style设置四条边框的样式。1border-top在一个声明中设置所有的上边框属性。1border-top-color设置上边框的颜色。2border-top-style设置上边框的样式。2border-top-width设置上边框的宽度。1border-width设置四条边框的宽度。1outline在一个声明中设置所有的轮廓属性。2outline-color设置轮廓的颜色。2outline-style设置轮廓的样式。2outline-width设置轮廓的宽度。2border-bottom-left-radius定义边框左下角的形状。3border-bottom-right-radius定义边框右下角的形状。3border-image简写属性，设置所有 border-image-属性* 。3border-image-outset规定边框图像区域超出边框的量。3border-image-repeat图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。3border-image-slice规定图像边框的向内偏移。3border-image-source规定用作边框的图片。3border-image-width规定图片边框的宽度。3border-radius简写属性，设置所有四个 border-属性*-radius 。3border-top-left-radius定义边框左上角的形状。3border-top-right-radius定义边框右下角的形状。 3 box-shadow向方框添加一个或多个阴影。3 Box属性属性描述CSSoverflow-x如果内容溢出了元素内容区域，是否对内容的左/右边缘进行裁剪。3overflow-y如果内容溢出了元素内容区域，是否对内容的上/下边缘进行裁剪。3overflow-style规定溢出元素的首选滚动方法。3rotation围绕由 rotation-point 属性定义的点对元素进行旋转。3rotation-point定义距离上左边框边缘的偏移点。3 QSS字体属性（Font）属性描述CSSfont在一个声明中设置所有字体属性。1font-family规定文本的字体系列。1font-size规定文本的字体尺寸。1font-size-adjust为元素规定 aspect 值。2font-stretch收缩或拉伸当前的字体系列。2font-style规定文本的字体样式。1font-variant规定是否以小型大写字母的字体显示文本。1font-weight规定字体的粗细。1 QSS外边距属性（Margin)属性描述CSSmargin在一个声明中设置所有外边距属性。1margin-bottom设置元素的下外边距。1margin-left设置元素的左外边距。1margin-right设置元素的右外边距。1margin-top设置元素的上外边距。1 QSS内边距属性（Padding)属性描述CSSpadding在一个声明中设置所有内边距属性。1padding-bottom设置元素的下内边距。1padding-left设置元素的左内边距。1padding-right设置元素的右内边距。1padding-top设置元素的上内边距。1 CSS定位属性（Positioning)属性描述CSSbottom设置定位元素下外边距边界与其包含块下边界之间的偏移。2clear规定元素的哪一侧不允许其他浮动元素。1clip剪裁绝对定位元素。2cursor规定要显示的光标的类型（形状）。2display规定元素应该生成的框的类型。1float规定框是否应该浮动。1left设置定位元素左外边距边界与其包含块左边界之间的偏移。2overflow规定当内容溢出元素框时发生的事情。2position规定元素的定位类型。2right设置定位元素右外边距边界与其包含块右边界之间的偏移。2top设置定位元素的上外边距边界与其包含块上边界之间的偏移。2vertical-align设置元素的垂直对齐方式。1visibility规定元素是否可见。2z-index设置元素的堆叠顺序。2 QSS文本属性（Text)属性描述CSScolor设置文本的颜色。1direction规定文本的方向 / 书写方向。2letter-spacing设置字符间距。1line-height设置行高。1text-align规定文本的水平对齐方式。1text-decoration规定添加到文本的装饰效果。1text-indent规定文本块首行的缩进。1text-shadow规定添加到文本的阴影效果。2text-transform控制文本的大小写。1unicode-bidi设置文本方向。2white-space规定如何处理元素中的空白。1word-spacing设置单词间距。1hanging-punctuation规定标点字符是否位于线框之外。3punctuation-trim规定是否对标点字符进行修剪。3text-align-last设置如何对齐最后一行或紧挨着强制换行符之前的行。3text-emphasis向元素的文本应用重点标记以及重点标记的前景色。3text-justify规定当 text-align 设置为 \"justify\" 时所使用的对齐方法。3text-outline规定文本的轮廓。3text-overflow规定当文本溢出包含元素时发生的事情。3text-shadow向文本添加阴影。3text-wrap规定文本的换行规则。3word-break规定非中日韩文本的换行规则。3word-wrap允许对长的不可分割的单词进行分割并换行到下一行。3 常见控件的QSS用法：QPushButton12345678910111213141516/*默认状态*/QPushButton&#123; background-color: transparent; /*背景颜色*/ padding:5px,5px,5px,5px;/*上右下左，设置控件的内边距*/ text-align:left;/*文字对齐方式*/&#125;/*鼠标悬浮*/ QPushButton:hover&#123; border-bottom:2px solid #079a18;/*底部边框粗细以及颜色设置*/ border-radius:0px;/*边框圆角设置*/&#125;/*鼠标按压*/QPushButton:pressed&#123; border-bottom:2px solid #5c940d;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://space.mearc.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://space.mearc.top/tags/Qt/"},{"name":"CSS","slug":"CSS","permalink":"https://space.mearc.top/tags/CSS/"}]},{"title":"Qt Installer Framework源码编译","slug":"Qt-QtInstallerFramework","date":"2022-12-11T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/12/Qt-QtInstallerFramework/","link":"","permalink":"https://space.mearc.top/2022/12/12/Qt-QtInstallerFramework/","excerpt":"","text":"准备工作源码下载地址：https://download.qt.io/official_releases/qt-installer-framework/ 解压源码windows: 使用解压工具解压Liunx:解压命令： 12345678// 压缩文件 file1 和目录 dir2 到 test.tar.gztar -zcvf test.tar.gz file1 dir2// 解压 test.tar.gz（将 c 换成 x 即可）tar -zxvf test.tar.gz// 解压 test.tar.xz（将 c 换成 x 即可）tar xvf test.tar.xz// 列出压缩文件的内容tar -ztvf test.tar.gz 静态编译：使用最新的Qt版本进行编译即可 Qt官方文档地址：https://doc.qt.io/qtinstallerframework/ifw-overview.html","categories":[{"name":"源码编译","slug":"源码编译","permalink":"https://space.mearc.top/categories/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://space.mearc.top/tags/Qt/"}]},{"title":"VPS原理及搭建方法","slug":"VPS-Theory","date":"2022-12-11T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/12/VPS-Theory/","link":"","permalink":"https://space.mearc.top/2022/12/12/VPS-Theory/","excerpt":"","text":"01 网络通信的基本过程 我们在浏览器中输入baidu.com这个网址，我们的网络是通过ip来定位某一台服务器的，域名仅仅是一串字符串，他绑定了一个ip地址。这个ip地址是找dns服务器获取。但是一开始不是直接去找dns服务器。 首先他会检查浏览器的缓存还有本地的缓存，里面有没有他的域名，如果浏览器里没有缓存就会检查本地的hosts文件，看看文件里面有没有添加映射关系。如果hosts文件里面也没有就会将请求发送到电脑配置的dns服务器上。 怎么发送到dns的服务器上去的？ 首先要了解一下OSI的七层模型 首先输入baidu.com，浏览并没有得到本地的百度ip地址，所以说他就会将请求发送到dns服务器上 dns是一个应用层的协议，它主要就是用来获取域名所绑定的ip地址，当传到应用层就会构造一个相关的协议，这个协议会生成一个相关的请求。然后，他要通过OSI模型一层一层往下传到物理层，也就是网卡的接口。生成请求数据之后，会传到传输层，他会对应用层的数据进行封装，他封装了一个源端口和目标端口，比如源端口404，目标端口，dns默认的是53号端口。然后将应用层传过来的协议和端口封装成一个数据包，然后接着往下传。传输层主要是有端口这个概念。 接下来来到网络层，网络层在前面也会封装一个包头，也就是源ip和目标ip，本机的电脑ip和你要访问的服务器ip，比如本机IP192.168.1.20 和dns服务器地址8.8.8.8。将和之前的数据封装号之后发送到链路层。网络层主要会添加ip地址。网络层封装数据之后，发现目标的ip地址并不在我的网段范围之内，找不到ip地址，接下里他就会去找网关。家里的网关一般是路由器。这里就可以将请求发送给网关。在同一个局域网里面通信，使用的mac地址，数据将会来到下一层。准备发往网关数据里。 数据链路层会在前面加上网关的mac地址和你的源mac地址。通过ARP协议来获取到网关的cc的mac地址。 接着，这条数据就会顺着物理层来到网卡的接口，他就会通过网卡从网线中发出去，来到了交换机的位置。 交换机他是一个二层的设备，也就是说他只能解析两层的数据。数据包从网卡来到交换机，交换机收到数据之后，看一下它里面的mac地址，源mac地址，接着，就将数据包转发到路由器mac地址为cc的这个端口。（路由器是一个三层设备，所以说它能解析三层的数据）。数据到达路由器端口之后，传到数据链路层，发现mac地址和我一样就会把它拿掉，然后就收这个数据包，接受之后就会把它的头部拿掉，拿掉之后在往上传，传到网络层，源ip地址和目标IP地址，发现没有8.8.8.8直接链接，那么路由器，它的工作就是把这个数据在路由出去，转发出去，路由器他会设置一个默认路由，当路由器发现找不到8.8.8.8的时候，他就会发送到默认路由，一般来说就直接发送到公网的其他的路由器了，于是他就会把这个数据转发给公网上的其他路由器，他会把我们的数据包从我们的WAN口（路由器中有一个颜色不一样的口，叫做WAN口，他是通往互联忘的道路），WAN口有一个公网的ip地址，也就是20.20.20.20，他需要将内网的数据转发出去，这里的话路由器还需要做一个NAT操作（网络地址转换）。因为源ip地址是一个内网的的网段，他不能在公网上进行传输，必须转成WAN口允许公网传输的这么一个协议。路由器中有一个NAT的映射表，他会先将本地的ip地址保存在在NAT映射表中，源ip地址和源端口放进去，然后将WAN公网ip地址放入网络层数据包的地址中，数据包的端口也会随便生成一个，同时也会在NAT映射表中记录一个他们之间的映射关系。之后路由器就会把数据包的ip和端口改掉，然后再回到数据链路层，然后在加上源mac地址和目标地址（注意：源mac地址就是现在的WAN口地址了，目标mac地址就是它的下一条的路由器的mac地址）。最后在来到物理层。最后他这个数据包就会从WAN口出去来到了互联网上的其他路由器，经过十来个路由器，最终找到dns服务器，然后将数据交给这台dns服务器。 我们知道dns是一个应用层的协议，所以这台服务器也能解析到应用层。 dns服务器拿到数据包之后，从物理层到数据链路层，解析mac地址正确，拿掉数据包的mac地址，然后在往上传这个数据包，网络层，传输层依旧如此。最后把这个报文发送给应用层的dns应用，dns收到这个请求后。生成一个dns的响应，之后就会沿着OSI模型往回传 补充 在传输层有两个协议一个是tcp，还有一个是udp。我们在应用层这个http的话，他是基于tcp的，我们要发送http请求，必须先使用tcp的方式跟访问的谷歌服务器建立连接，才能发送http请求。 现在要访问谷歌，得到正确的ip地址之后，我们要先发送一个tcp建立连接的请求 ，比如说，发送一个连接请求，来到传输层，用源端口和目标端口建立连接，一系列操作后，来到物理层发送出去，发现ip不在国内，于是会经过防火墙（GFW），经过防火墙的时候，（这个防火墙强大到可以解析应用层的流量）防火墙里有一个列表，记录了一些黑名单的ip地址或者域名之类的，或者防火墙可以伪装的谷歌服务器，给你返回数据包。（tcp重置攻击） 当与服务器建立连接发送请求后，如果数据包里面有关于google 的信息，GFW也会把它干掉，虽然已经与服务器建立连接，但是数据根本就传不出去 02 墙拦截的原理与绕过当浏览器发送一个请求，发送的谷歌服务器，当返回回来之后，GFW会在返回的ip里面动一些手脚，本地收到数据包之后，由应用层解析完毕之后，于是我们就拿到了一个假的IP地址（DNS污染 ，也可以叫dns劫持）。 这个时候我们如果不发送dns请求，他就不会造成dns污染。当我们浏览器访问谷歌的一瞬间，他并不是直接发送dns，而是先检查本地的dns缓存，如果没有再去检查hosts文件。如果hosts文件中有ip和域名的映射关系，当浏览器发起的时候，而是直接找到hosts文件，应为hosts文件里面添加了映射关系，他就会直接使用这个ip，不需要在发送dns请求，去通过dns获取ip地址。 经过以上集中凡是的拦截，我们的路就会被卡的死死的，我们第一时间想到的就是使用代理进行访问，我们接触最后的代理方式就是http代理和socks5代理。比如我们在vps上搭建一个socks5的服务，监听了一个端口1080，我们就可以构建一个数据包，发往这台vps6.6.6.6 端口1080，和这个端口建立连接。虽然说确实可以正常访问谷歌服务器，也没有经过防火墙，但是从我们这里发出去就不行了，比如说，我们发送到防火墙这里，众所周知，防火墙可以解析到应用层，也就是说它可以看到里面的内容， 看到想让vps这台服务器帮你解析谷歌，他又会帮你干掉了 为什么可以如此精确的阻断连接？ 归根结底，我们的意图被它看到了，它可以解析里面的数据内容 怎么才能让他看不到里面的内容？ 加密，vpn他就是会加密数据流量的，比如我们经常使用的IPsec，或者openVpn，这些协议他都可以进行对数据加密。那么这种传统的vpn虽然可以进行对数据加密，但是他的特征会非常明显，也就是说虽然防火墙它看不到我们的数据内容，但是它能知道我们在进行vpn连接。 那么要怎么做才能既加密流量又没有特征呢？ shadowsocks，这个协议一出生就是为了绕过防火墙的检查 假设在vps上搭建一个ss的服务端，它监听一个端口8388，同时我们本机运行一个ss客户端，然后它监听一个端口1080，socks5的端口，同时我们的浏览器设置了一个代理端口，也就是说我们浏览器的访问请求会先走这个代理端口（1080），ip地址就是本机127.0.0.1，就相当于我们在浏览器中发送一个访问谷歌请求的时候，这个请求会转发到本机的1080这个端口， 那么这个端口是由ss的客户端在监听，那么这个请求就会发送到ss的客户端，客户端拿到这个请求，他会对这个请求加密，会把里面的内容加密，加密之后我们是看不到数据包里面的内容，然后就会来到传输层，那么他会从源端口是监听1080，目标端口就是客户端里面配置好的需要连接的服务器（8388），最后由物理层发送出去。防火墙放行通过后，就会路由到vps服务器，服务器拿到数据包，解析8388端口，是ss服务端处理，拿到数据之后进行解密，解密之后就会获得原始的请求，他会代替你访问谷歌，他会从谷歌得到一份响应， 收到数据后，同样也会对数据进行加密，加密之后重新构造一个数据包，返回给客户端，最后客户端会得到这个数据包，ss客户端拿到数据之后将会返回给浏览器，浏览器拿到数据之后就可以愉快的访问了。 03 节点搭建vps 虚拟专用服务器（英语：Virtual private server，缩写为VPS），是将一台服务器分割成多个虚拟专用服务器的服务。实现VPS的技术分为容器技术和虚拟机技术。在容器或虚拟机中，每个VPS都可分配独立公网IP地址、独立操作系统、实现不同VPS间磁盘空间、内存、CPU资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。VPS可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。VPS为用户提供了管理配置的自由，可用于企业虚拟化，也可以用于IDC资源租用。 购买vps服务器 vultr ：https://www.vultr.com/ 第二个相对比较实惠； 在Linux下搭建shadonsocks服务端 shadownsocks相关命令 12345678910# 安装shadowsocksapt install shadowsocks-libev# 查看shadowsocks状态systemctl status shadowsocks-libev.service# 编辑ss配置文件vim /etc/shadowsocks-libev/config.json# 重启shadowsockssystemctl restart shadowsocks-libev.service# 查看shadowsocks运行日志：journalctl -u shadowsocks-libev.service -f Ubuntu防火墙设置 123456789101112# 查看状态ufw status# 开放端口ufw allow 8388# 拒绝端口ufw deny 8388# 删除规则ufw delete allow 8388# 关闭防火墙ufw disable# 启动防火墙ufw enable 相关命令解释 vim /etc/shadowsocks-libev/config.json 需要将IP地址改成0.0.0.0,改成0的意思是接受所有ip地址往他的8388端口发送数据，默认是只允许本机（127.0.0.1环回地址）的地址发送数据。 密码需要一样，因为它使用的是对称加密算法，并且加密方式为GCM的格式，这种加密方式是带身份认证的 12345678910111213141516171819202122&#123; &quot;server&quot;:[&quot;::1&quot;, &quot;0.0.0.0&quot;], &quot;mode&quot;:&quot;tcp_and_udp&quot;, &quot;server_port&quot;:8388, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;k58LRQwcnKqb&quot;, &quot;timeout&quot;:86400, &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;&#125;&#123; &quot;server&quot;:[&quot;::1&quot;, &quot;0.0.0.0&quot;], &quot;mode&quot;:&quot;tcp_and_udp&quot;, &quot;server_port&quot;:8388, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;h0rc6ZWBBaRI&quot;, &quot;timeout&quot;:86400, &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;&#125; 重放攻击：假设电脑生成一个数据包，往服务器上发，其中经过了防火墙，防火墙它也可以拿着你的数据主动往服务器上发送，用你的数据发送，这就是一个重放攻击。它的探测目的就是为了了解你这个服务器上是否运行了某些服务，比如shadowsockes。具体怎么探测到就不得而知了。 相关连接 SSH连接工具（FinalShell）：http://www.hostbuf.com/t/988.htmlSS客户端(shadowsocks-windows)： https://github.com/shadowsocks/shadowsocks-windowsshadowsocks插件(v2ray-plugin)：https://github.com/shadowsocks/v2ray-plugin方便测速但不支持ss插件(v2rayN)：https://github.com/2dust/v2rayN Tcpping测试连接显示timeout，也就是没办法和vps进行通讯，这是为什么呢？ 因为服务器上的防火墙没有关，在服务器的外围，其实还有一层防火墙，刚安装好只开放了一个22号端口，也就是说我们从外面往它里面发送数据，他只允许访问22号端口，8388端口是不允许访问的。 在外面发送请求的时候，防火墙马上发送了一个探测包，这个防火墙拿这我们的数据，他也主动往服务器发送了一次，然后我们服务器显示认证失败，但是这个防火墙已经得到了它想要的。他可能在这一次探测当中，就已经知道了你这里已经运行了shadowsocks的服务，虽然说他可能防重放攻击，但是防火墙已经达到的探测目的，当他已经知道你这里运行了shadowsocks的服务的时候，他就会把你们的连接切断。 既然能被探测那么ss节点是不是没办法用了？理论上来说确实是，但是ss协议引入了plagin功能，它主要的功能就是对数据流量进行伪装，比如说把我们经过ss假币后的数据流量伪装成普通的http或者websocket这种协议的流量。 首先浏览器会构建一个请求，由于我们设置了系统代理，所以说他会把这个请求发送到配置的系统代理，也就是1080端口，这个数据就会来到ss客户端，因为它监听了客户端，会使用ss客户端的加密方式和密码对请求进行加密，如果没有插件就会直接传到防火墙，但是加了插件，会传到插件这里，他会对这个数据流量进行伪装（比如会伪装成http协议头的头），让防火墙以为我们在访问一个正常的网站，当防火墙发现他只是一个普通的http流量的时候，就可能不会再向服务器发送探测包了。于是数据包就会放行通过，当来到vps时，插件拿到数据的时候会把协议头去掉，之后就把真正的数据发往服务端了。这就是plagin的原理，主要起到了流量伪装的作用。 ssr节点就是类似加了插件的ss节点 服务端安装plugin插件 apt install shadowsocks-v2ray-plugin 修改配置文件 1234567891011&#123; &quot;server&quot;:[&quot;::1&quot;, &quot;0.0.0.0&quot;], &quot;mode&quot;:&quot;tcp_and_udp&quot;, &quot;server_port&quot;:28388, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;k58LRQwcnKqb&quot;, &quot;timeout&quot;:86400, &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;, &quot;plugin&quot;:&quot;ss-v2ray-plugin&quot;, &quot;plugin_opts&quot;:&quot;server&quot;&#125; 客户端安装shadowsocks与v2ray-plugin插件 安装完成之后将v2ray-plug插件放入shadowsocks目录中","categories":[{"name":"网络通信","slug":"网络通信","permalink":"https://space.mearc.top/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"VPS","slug":"VPS","permalink":"https://space.mearc.top/tags/VPS/"}]},{"title":"C++基础入门","slug":"CPP-Basic","date":"2022-12-10T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/11/CPP-Basic/","link":"","permalink":"https://space.mearc.top/2022/12/11/CPP-Basic/","excerpt":"","text":"C++基础入门1 C++初识1.1 第一个C++程序编写一个C++程序总共分为4个步骤 创建项目 创建文件 编写代码 运行程序 1.1.1 创建项目​ Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开 1.1.2 创建文件右键源文件，选择添加-&gt;新建项 给C++文件起个名称，然后点击添加即可。 1.1.3 编写代码1234567891011#include&lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 1.1.4 运行程序 1.2 注释作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码 两种格式 单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明== 多行注释： /* 描述信息 */ 通常放在一段代码的上方，==对该段代码做整体说明== 提示：编译器在编译代码时，会忽略注释的内容 1.3 变量作用：给一段指定的内存空间起名，方便操作这段内存 语法：数据类型 变量名 = 初始值; 示例： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main() &#123; //变量的定义 //语法：数据类型 变量名 = 初始值 int a = 10; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 注意：C++在创建变量时，必须给变量一个初始值，否则会报错 1.4 常量作用：用于记录程序中不可更改的数据 C++定义常量两种方式 #define 宏常量： #define 常量名 常量值 ==通常在文件上方定义==，表示一个常量 const修饰的变量 const 数据类型 常量名 = 常量值 ==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改 示例： 123456789101112131415161718//1、宏常量#define day 7int main() &#123; cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl; //day = 8; //报错，宏常量不可以修改 //2、const修饰变量 const int month = 12; cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl; //month = 24; //报错，常量是不可以修改的 system(&quot;pause&quot;); return 0;&#125; 1.5 关键字作用：关键字是C++中预先保留的单词（标识符） 在定义变量或者常量时候，不要用关键字 C++关键字如下： asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。 1.6 标识符命名规则作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则 标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读 2 数据类型C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存 2.1 整型作用：整型变量表示的是==整数类型==的数据 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同： 数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 sizeof关键字作用：利用sizeof关键字可以==统计数据类型所占内存大小== 语法： sizeof( 数据类型 / 变量) 示例： 1234567891011121314int main() &#123; cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl; cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl; cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 整型结论：==short &lt; int &lt;= long &lt;= long long== 2.3 实型（浮点型）作用：用于==表示小数== 浮点型变量分为两种： 单精度float 双精度double 两者的区别在于表示的有效数字范围不同。 数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例： 12345678910111213141516171819202122int main() &#123; float f1 = 3.14f; double d1 = 3.14; cout &lt;&lt; f1 &lt;&lt; endl; cout &lt;&lt; d1&lt;&lt; endl; cout &lt;&lt; &quot;float sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl; cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl; //科学计数法 float f2 = 3e2; // 3 * 10 ^ 2 cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl; float f3 = 3e-2; // 3 * 0.1 ^ 2 cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.4 字符型作用：字符型变量用于显示单个字符 语法：char ch = &#39;a&#39;; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 C和C++中字符型变量只占用==1个字节==。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例： 1234567891011121314151617int main() &#123; char ch = &#x27;a&#x27;; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; sizeof(char) &lt;&lt; endl; //ch = &quot;abcde&quot;; //错误，不可以用双引号 //ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符 cout &lt;&lt; (int)ch &lt;&lt; endl; //查看字符a对应的ASCII码 ch = 97; //可以直接用ASCII给字符型变量赋值 cout &lt;&lt; ch &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; ASCII码表格： ASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成： ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 2.5 转义字符作用：用于表示一些==不能显示出来的ASCII字符== 现阶段我们常用的转义字符有： \\n \\\\ \\t 转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 *\\\\* 代表一个反斜线字符”&quot; 092 &#39; 代表一个单引号（撇号）字符 039 &quot; 代表一个双引号字符 034 ? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围09，af，A~F 3位16进制 示例： 1234567891011int main() &#123; cout &lt;&lt; &quot;\\\\&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\tHello&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.6 字符串型作用：用于表示一串字符 两种风格 C风格字符串： char 变量名[] = &quot;字符串值&quot; 示例： 123456789int main() &#123; char str1[] = &quot;hello world&quot;; cout &lt;&lt; str1 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 注意：C风格的字符串要用双引号括起来 C++风格字符串： string 变量名 = &quot;字符串值&quot; 示例： 123456789int main() &#123; string str = &quot;hello world&quot;; cout &lt;&lt; str &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;== 2.7 布尔类型 bool作用：布尔数据类型代表真或假的值 bool类型只有两个值： true — 真（本质是1） false — 假（本质是0） bool类型占==1个字节==大小 示例： 1234567891011121314int main() &#123; bool flag = true; cout &lt;&lt; flag &lt;&lt; endl; // 1 flag = false; cout &lt;&lt; flag &lt;&lt; endl; // 0 cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1 system(&quot;pause&quot;); return 0;&#125; 2.8 数据的输入作用：用于从键盘获取数据 关键字：cin 语法： cin &gt;&gt; 变量 示例： 12345678910111213141516171819202122232425262728293031323334int main()&#123; //整型输入 int a = 0; cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl; cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt; endl; //浮点型输入 double d = 0; cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; //字符型输入 char ch = 0; cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; //字符串型输入 string str; cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; //布尔类型输入 bool flag = true; cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl; cin &gt;&gt; flag; cout &lt;&lt; flag &lt;&lt; endl; system(&quot;pause&quot;); return EXIT_SUCCESS;&#125; 3 运算符作用：用于执行代码的运算 本章我们主要讲解以下几类运算符： 运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 3.1 算术运算符作用：用于处理四则运算 算术运算符包括以下符号： 运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; – 前置递减 a=2; b=–a; a=1; b=1; – 后置递减 a=2; b=a–; a=1; b=2; 示例1： 1234567891011121314151617181920212223242526272829//加减乘除int main() &#123; int a1 = 10; int b1 = 3; cout &lt;&lt; a1 + b1 &lt;&lt; endl; cout &lt;&lt; a1 - b1 &lt;&lt; endl; cout &lt;&lt; a1 * b1 &lt;&lt; endl; cout &lt;&lt; a1 / b1 &lt;&lt; endl; //两个整数相除结果依然是整数 int a2 = 10; int b2 = 20; cout &lt;&lt; a2 / b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0 //两个小数可以相除 double d1 = 0.5; double d2 = 0.25; cout &lt;&lt; d1 / d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：在除法运算中，除数不能为0 示例2： 1234567891011121314151617181920212223242526272829//取模int main() &#123; int a1 = 10; int b1 = 3; cout &lt;&lt; 10 % 3 &lt;&lt; endl; int a2 = 10; int b2 = 20; cout &lt;&lt; a2 % b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0 //两个小数不可以取模 double d1 = 3.14; double d2 = 1.1; //cout &lt;&lt; d1 % d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：只有整型变量可以进行取模运算 示例3： 1234567891011121314151617181920212223242526272829//递增int main() &#123; //后置递增 int a = 10; a++; //等价于a = a + 1 cout &lt;&lt; a &lt;&lt; endl; // 11 //前置递增 int b = 10; ++b; cout &lt;&lt; b &lt;&lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：前置递增先对变量进行++，再计算表达式，后置递增相反 3.2 赋值运算符作用：用于将表达式的值赋给变量 赋值运算符包括以下几个符号： 运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例： 1234567891011121314151617181920212223242526272829303132333435363738int main() &#123; //赋值运算符 // = int a = 10; a = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // += a = 10; a += 2; // a = a + 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // -= a = 10; a -= 2; // a = a - 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // *= a = 10; a *= 2; // a = a * 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // /= a = 10; a /= 2; // a = a / 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // %= a = 10; a %= 2; // a = a % 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 3.3 比较运算符作用：用于表达式的比较，并返回一个真值或假值 比较运算符有以下符号： 运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 &lt; 小于 4 &lt; 3 0 &gt; 大于 4 &gt; 3 1 &lt;= 小于等于 4 &lt;= 3 0 &gt;= 大于等于 4 &gt;= 1 1 示例： 123456789101112131415161718192021int main() &#123; int a = 10; int b = 20; cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 cout &lt;&lt; (a != b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0;&#125; 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== 3.4 逻辑运算符作用：用于根据表达式的值返回真值或假值 逻辑运算符有以下符号： 运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 &amp;&amp; 与 a &amp;&amp; b 如果a和b都为真，则结果为真，否则为假。 || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 示例1：逻辑非 12345678910111213//逻辑运算符 --- 非int main() &#123; int a = 10; cout &lt;&lt; !a &lt;&lt; endl; // 0 cout &lt;&lt; !!a &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0;&#125; 总结： 真变假，假变真 示例2：逻辑与 1234567891011121314151617181920212223//逻辑运算符 --- 与int main() &#123; int a = 10; int b = 10; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 a = 0; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0;&#125; 总结：逻辑==与==运算符总结： ==同真为真，其余为假== 示例3：逻辑或 12345678910111213141516171819202122//逻辑运算符 --- 或int main() &#123; int a = 10; int b = 10; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 0; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0;&#125; 逻辑==或==运算符总结： ==同假为假，其余为真== 4 程序流程结构C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构== 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 4.1 选择结构4.1.1 if语句作用：执行满足条件的语句 if语句的三种形式 单行格式if语句 多行格式if语句 多条件的if语句 单行格式if语句：if(条件)&#123; 条件满足执行的语句 &#125; 示例： 12345678910111213141516171819202122int main() &#123; //选择结构-单行if语句 //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score = 0; cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl; //if语句 //注意事项，在if判断语句后面，不要加分号 if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 注意：if条件表达式后不要加分号 多行格式if语句：if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;; 示例： 123456789101112131415161718192021int main() &#123; int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 多条件的if语句：if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125; 示例： 1234567891011121314151617181920212223242526272829 int main() &#123; int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断 案例需求： 提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142int main() &#123; int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; if (score &gt; 700) &#123; cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl; &#125; else if (score &gt; 650) &#123; cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl; &#125; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 练习案例： 三只小猪称体重 有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？ 4.1.2 三目运算符作用： 通过三目运算符实现简单的判断 语法：表达式1 ? 表达式2 ：表达式3 解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果； 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。 示例： 123456789101112131415161718192021int main() &#123; int a = 10; int b = 20; int c = 0; c = a &gt; b ? a : b; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰 4.1.3 switch语句作用：执行多条件分支语句 语法： 1234567891011121314switch(表达式)&#123; case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break;&#125; 示例： 12345678910111213141516171819202122232425262728293031323334int main() &#123; //请给电影评分 //10 ~ 9 经典 // 8 ~ 7 非常好 // 6 ~ 5 一般 // 5分以下 烂片 int score = 0; cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl; cin &gt;&gt; score; switch (score) &#123; case 10: case 9: cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl; break; case 8: cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl; break; case 7: case 6: cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl; break; default: cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl; break; &#125; system(&quot;pause&quot;); return 0;&#125; 注意1：switch语句中表达式类型只能是整型或者字符型 注意2：case里如果没有break，那么程序会一直向下执行 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间 4.2 循环结构4.2.1 while循环语句作用：满足循环条件，执行循环语句 语法： while(循环条件)&#123; 循环语句 &#125; 解释：==只要循环条件的结果为真，就执行循环语句== 示例： 12345678910111213int main() &#123; int num = 0; while (num &lt; 10) &#123; cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; num++; &#125; system(&quot;pause&quot;); return 0;&#125; 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环 while循环练习案例：==猜数字== 案例描述：系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。 4.2.2 do…while循环语句作用： 满足循环条件，执行循环语句 语法： do&#123; 循环语句 &#125; while(循环条件); 注意：与while的区别在于==do…while会先执行一次循环语句==，再判断循环条件 示例： 12345678910111213141516int main() &#123; int num = 0; do &#123; cout &lt;&lt; num &lt;&lt; endl; num++; &#125; while (num &lt; 10); system(&quot;pause&quot;); return 0;&#125; 总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件 练习案例：水仙花数 案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身 例如：1^3 + 5^3+ 3^3 = 153 请利用do…while语句，求出所有3位数中的水仙花数 4.2.3 for循环语句作用： 满足循环条件，执行循环语句 语法： for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125; 示例： 1234567891011int main() &#123; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 详解： 注意：for循环中的表达式，要用分号进行分隔 总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用 练习案例：敲桌子 案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。 4.2.4 嵌套循环作用： 在循环体中再嵌套一层循环，解决一些实际问题 例如我们想在屏幕中打印如下图片，就需要利用嵌套循环 示例： 12345678910111213141516int main() &#123; //外层循环执行1次，内层循环执行1轮 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 练习案例：乘法口诀表 案例描述：利用嵌套循环，实现九九乘法表 4.3 跳转语句4.3.1 break语句作用: 用于跳出==选择结构==或者==循环结构== break使用的时机： 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1： 12345678910111213141516171819202122232425262728int main() &#123; //1、在switch 语句中使用break cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl; int num = 0; cin &gt;&gt; num; switch (num) &#123; case 1: cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl; break; case 2: cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl; break; case 3: cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl; break; &#125; system(&quot;pause&quot;); return 0;&#125; 示例2： 123456789101112131415int main() &#123; //2、在循环语句中用break for (int i = 0; i &lt; 10; i++) &#123; if (i == 5) &#123; break; //跳出循环语句 &#125; cout &lt;&lt; i &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 示例3： 12345678910111213141516171819int main() &#123; //在嵌套循环语句中使用break，退出内层循环 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; if (j == 5) &#123; break; &#125; cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 4.3.2 continue语句作用：在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 示例： 123456789101112131415int main() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; continue; &#125; cout &lt;&lt; i &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 注意：continue并没有使整个循环终止，而break会跳出循环 4.3.3 goto语句作用：可以无条件跳转语句 语法： goto 标记; 解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 示例： 123456789101112131415161718int main() &#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; goto FLAG; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3&quot; &lt;&lt; endl; cout &lt;&lt; &quot;4&quot; &lt;&lt; endl; FLAG: cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 注意：在程序中不建议使用goto语句，以免造成程序流程混乱 5 数组5.1 概述所谓数组，就是一个集合，里面存放了相同类型的数据元素 特点1：数组中的每个==数据元素都是相同的数据类型== 特点2：数组是由==连续的内存==位置组成的 5.2 一维数组5.2.1 一维数组定义方式一维数组定义的三种方式： 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;; 数据类型 数组名[ ] = &#123; 值1，值2 ...&#125;; 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445int main() &#123; //定义方式1 //数据类型 数组名[元素个数]; int score[10]; //利用下标赋值 score[0] = 100; score[1] = 99; score[2] = 85; //利用下标输出 cout &lt;&lt; score[0] &lt;&lt; endl; cout &lt;&lt; score[1] &lt;&lt; endl; cout &lt;&lt; score[2] &lt;&lt; endl; //第二种定义方式 //数据类型 数组名[元素个数] = &#123;值1，值2 ，值3 ...&#125;; //如果&#123;&#125;内不足10个数据，剩余数据用0补全 int score2[10] = &#123; 100, 90,80,70,60,50,40,30,20,10 &#125;; //逐个输出 //cout &lt;&lt; score2[0] &lt;&lt; endl; //cout &lt;&lt; score2[1] &lt;&lt; endl; //一个一个输出太麻烦，因此可以利用循环进行输出 for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; score2[i] &lt;&lt; endl; &#125; //定义方式3 //数据类型 数组名[] = &#123;值1，值2 ，值3 ...&#125;; int score3[] = &#123; 100,90,80,70,60,50,40,30,20,10 &#125;; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; score3[i] &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名 总结2：数组中下标是从0开始索引 5.2.2 一维数组数组名一维数组名称的用途： 可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址 示例： 12345678910111213141516171819202122int main() &#123; //数组名用途 //1、可以获取整个数组占用内存空间大小 int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; //2、可以通过数组名获取到数组首地址 cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl; cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl; //arr = 100; 错误，数组名是常量，因此不可以赋值 system(&quot;pause&quot;); return 0;&#125; 注意：数组名是常量，不可以赋值 总结1：直接打印数组名，可以查看数组所占内存的首地址 总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小 练习案例1：五只小猪称体重 案例描述： 在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250}; 找出并打印最重的小猪体重。 练习案例2：数组元素逆置 案例描述：请声明一个5个元素的数组，并且将元素逆置. (如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1); 5.2.3 冒泡排序作用： 最常用的排序算法，对数组内元素进行排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较 示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序 1234567891011121314151617181920212223242526int main() &#123; int arr[9] = &#123; 4,2,8,0,5,7,1,3,9 &#125;; for (int i = 0; i &lt; 9 - 1; i++) &#123; for (int j = 0; j &lt; 9 - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; 9; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/ 5.3 二维数组二维数组就是在一维数组上，多加一个维度。 5.3.1 二维数组定义方式二维数组定义的四种方式： 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;; 数据类型 数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;; 数据类型 数组名[ ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;; 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性== 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041int main() &#123; //方式1 //数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //方式2 //数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;; int arr2[2][3] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125; &#125;; //方式3 //数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4 &#125;; int arr3[2][3] = &#123; 1,2,3,4,5,6 &#125;; //方式4 //数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4 &#125;; int arr4[][3] = &#123; 1,2,3,4,5,6 &#125;; system(&quot;pause&quot;); return 0;&#125; 总结：在定义二维数组时，如果初始化了数据，可以省略行数 5.3.2 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址 示例： 12345678910111213141516171819202122232425262728int main() &#123; //二维数组数组名 int arr[2][3] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125; &#125;; cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl; //地址 cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结1：二维数组名就是这个数组的首地址 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小 5.3.3 二维数组应用案例考试成绩统计： 案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩 语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 参考答案： 12345678910111213141516171819202122232425int main() &#123; int scores[3][3] = &#123; &#123;100,100,100&#125;, &#123;90,50,100&#125;, &#123;60,70,80&#125;, &#125;; string names[3] = &#123; &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; &#125;; for (int i = 0; i &lt; 3; i++) &#123; int sum = 0; for (int j = 0; j &lt; 3; j++) &#123; sum += scores[i][j]; &#125; cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 6 函数6.1 概述作用：将一段经常使用的代码封装起来，减少重复代码 一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。 6.2 函数的定义函数的定义一般主要有5个步骤： 1、返回值类型 2、函数名 3、参数表列 4、函数体语句 5、return 表达式 语法： 12345678返回值类型 函数名 （参数列表）&#123; 函数体语句 return表达式&#125; 返回值类型 ：一个函数可以返回一个值。在函数定义中 函数名：给函数起个名称 参数列表：使用该函数时，传入的数据 函数体语句：花括号内的代码，函数内需要执行的语句 return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据 示例：定义一个加法函数，实现两个数相加 123456//函数定义int add(int num1, int num2)&#123; int sum = num1 + num2; return sum;&#125; 6.3 函数的调用功能：使用定义好的函数 语法： 函数名（参数） 示例： 12345678910111213141516171819202122232425//函数定义int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参&#123; int sum = num1 + num2; return sum;&#125;int main() &#123; int a = 10; int b = 10; //调用add函数 int sum = add(a, b);//调用时的a，b称为实际参数，简称实参 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; a = 100; b = 100; sum = add(a, b); cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参 6.4 值传递 所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，==如果形参发生，并不会影响实参== 示例： 12345678910111213141516171819202122232425262728293031void swap(int num1, int num2)&#123; cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; int temp = num1; num1 = num2; num2 = temp; cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; //return ; 当函数声明时候，不需要返回值，可以不写return&#125;int main() &#123; int a = 10; int b = 20; swap(a, b); cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结： 值传递时，形参是修饰不了实参的 6.5 函数的常见样式常见的函数样式有4种 无参无返 有参无返 无参有返 有参有返 示例： 123456789101112131415161718192021222324252627282930//函数常见样式//1、 无参无返void test01()&#123; //void a = 10; //无类型不可以创建变量,原因无法分配内存 cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl; //test01(); 函数调用&#125;//2、 有参无返void test02(int a)&#123; cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;&#125;//3、无参有返int test03()&#123; cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl; return 10;&#125;//4、有参有返int test04(int a, int b)&#123; cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl; int sum = a + b; return sum;&#125; 6.6 函数的声明作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数的声明可以多次，但是函数的定义只能有一次 示例： 123456789101112131415161718192021//声明可以多次，定义只能一次//声明int max(int a, int b);int max(int a, int b);//定义int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main() &#123; int a = 100; int b = 200; cout &lt;&lt; max(a, b) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 6.7 函数的分文件编写作用：让代码结构更加清晰 函数分文件编写一般有4个步骤 创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义 示例： 1234567//swap.h文件#include&lt;iostream&gt;using namespace std;//实现两个数字交换的函数声明void swap(int a, int b); 123456789101112//swap.cpp文件#include &quot;swap.h&quot;void swap(int a, int b)&#123; int temp = a; a = b; b = temp; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125; 12345678910111213//main函数文件#include &quot;swap.h&quot;int main() &#123; int a = 100; int b = 200; swap(a, b); system(&quot;pause&quot;); return 0;&#125; 7 指针7.1 指针的基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 7.2 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名； 示例： 123456789101112131415161718192021int main() &#123; //1、指针的定义 int a = 10; //定义整型变量a //指针定义语法： 数据类型 * 变量名 ; int * p; //指针变量赋值 p = &amp;a; //指针指向变量a的地址 cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址 cout &lt;&lt; p &lt;&lt; endl; //打印指针变量p //2、指针的使用 //通过*操作指针变量指向的内存 cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 指针变量和普通变量的区别 普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用 总结1： 我们可以通过 &amp; 符号 获取变量的地址 总结2：利用指针可以记录地址 总结3：对指针变量解引用，可以操作指针指向的内存 7.3 指针所占内存空间提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？ 示例： 1234567891011121314151617int main() &#123; int a = 10; int * p; p = &amp;a; //指针指向数据a的地址 cout &lt;&lt; *p &lt;&lt; endl; //* 解引用 cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; sizeof(double *) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：所有指针类型在32位操作系统下是4个字节 7.4 空指针和野指针空指针：指针变量指向内存中编号为0的空间 用途：初始化指针变量 注意：空指针指向的内存是不可以访问的 示例1：空指针 12345678910111213int main() &#123; //指针变量p指向内存地址编号为0的空间 int * p = NULL; //访问空指针报错 //内存编号0 ~255为系统占用内存，不允许用户访问 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 野指针：指针变量指向非法的内存空间 示例2：野指针 123456789101112int main() &#123; //指针变量p指向内存地址编号为0x1100的空间 int * p = (int *)0x1100; //访问野指针报错 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：空指针和野指针都不是我们申请的空间，因此不要访问。 7.5 const修饰指针const修饰指针有三种情况 const修饰指针 — 常量指针 const修饰常量 — 指针常量 const即修饰指针，又修饰常量 示例： 12345678910111213141516171819202122232425int main() &#123; int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 = &amp;a; p1 = &amp;b; //正确 //*p1 = 100; 报错 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 = &amp;a; //p2 = &amp;b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int * const p3 = &amp;a; //p3 = &amp;b; //错误 //*p3 = 100; //错误 system(&quot;pause&quot;); return 0;&#125; 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量 7.6 指针和数组作用：利用指针访问数组中元素 示例： 1234567891011121314151617181920int main() &#123; int arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; int * p = arr; //指向数组的指针 cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; //利用指针遍历数组 cout &lt;&lt; *p &lt;&lt; endl; p++; &#125; system(&quot;pause&quot;); return 0;&#125; 7.7 指针和函数作用：利用指针作函数参数，可以修改实参的值 示例： 12345678910111213141516171819202122232425262728293031//值传递void swap1(int a ,int b)&#123; int temp = a; a = b; b = temp;&#125;//地址传递void swap2(int * p1, int *p2)&#123; int temp = *p1; *p1 = *p2; *p2 = temp;&#125;int main() &#123; int a = 10; int b = 20; swap1(a, b); // 值传递不会改变实参 swap2(&amp;a, &amp;b); //地址传递会改变实参 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递 7.8 指针、数组、函数案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序 例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; 示例： 123456789101112131415161718192021222324252627282930313233343536373839//冒泡排序函数void bubbleSort(int * arr, int len) //int * arr 也可以写为int arr[]&#123; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;//打印数组函数void printArray(int arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;int main() &#123; int arr[10] = &#123; 4,3,6,9,1,2,10,8,7,5 &#125;; int len = sizeof(arr) / sizeof(int); bubbleSort(arr, len); printArray(arr, len); system(&quot;pause&quot;); return 0;&#125; 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针 8 结构体8.1 结构体基本概念结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型 8.2 结构体定义和使用语法：struct 结构体名 &#123; 结构体成员列表 &#125;； 通过结构体创建变量的方式有三种： struct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值…} 定义结构体时顺便创建变量 示例： 1234567891011121314151617181920212223242526272829303132333435363738//结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;stu3; //结构体变量创建方式3 int main() &#123; //结构体变量创建方式1 struct student stu1; //struct 关键字可以省略 stu1.name = &quot;张三&quot;; stu1.age = 18; stu1.score = 100; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl; //结构体变量创建方式2 struct student stu2 = &#123; &quot;李四&quot;,19,60 &#125;; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl; stu3.name = &quot;王五&quot;; stu3.age = 18; stu3.score = 80; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结1：定义结构体时的关键字是struct，不可省略 总结2：创建结构体变量时，关键字struct可以省略 总结3：结构体变量利用操作符 ‘’.’’ 访问成员 8.3 结构体数组作用：将自定义的结构体放入到数组中方便维护 语法： struct 结构体名 数组名[元素个数] = &#123; &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125; 示例： 12345678910111213141516171819202122232425262728//结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;int main() &#123; //结构体数组 struct student arr[3]= &#123; &#123;&quot;张三&quot;,18,80 &#125;, &#123;&quot;李四&quot;,19,60 &#125;, &#123;&quot;王五&quot;,20,70 &#125; &#125;; for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 8.4 结构体指针作用：通过指针访问结构体中的成员 利用操作符 -&gt; 可以通过结构体指针访问结构体属性 示例： 123456789101112131415161718192021222324//结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;int main() &#123; struct student stu = &#123; &quot;张三&quot;,18,100, &#125;; struct student * p = &amp;stu; p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员 8.5 结构体嵌套结构体作用： 结构体中的成员可以是另一个结构体 例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体 示例： 123456789101112131415161718192021222324252627282930313233343536373839//学生结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;//教师结构体定义struct teacher&#123; //成员列表 int id; //职工编号 string name; //教师姓名 int age; //教师年龄 struct student stu; //子结构体 学生&#125;;int main() &#123; struct teacher t1; t1.id = 10000; t1.name = &quot;老王&quot;; t1.age = 40; t1.stu.name = &quot;张三&quot;; t1.stu.age = 18; t1.stu.score = 100; cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl; cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题 8.6 结构体做函数参数作用：将结构体作为参数向函数中传递 传递方式有两种： 值传递 地址传递 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//学生结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;//值传递void printStudent(student stu )&#123; stu.age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;&#125;//地址传递void printStudent2(student *stu)&#123; stu-&gt;age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123; student stu = &#123; &quot;张三&quot;,18,100&#125;; //值传递 printStudent(stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; cout &lt;&lt; endl; //地址传递 printStudent2(&amp;stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递 8.7 结构体中 const使用场景作用：用const来防止误操作 示例： 123456789101112131415161718192021222324252627//学生结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;//const使用场景void printStudent(const student *stu) //加const防止函数体中的误操作&#123; //stu-&gt;age = 100; //操作失败，因为加了const修饰 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123; student stu = &#123; &quot;张三&quot;,18,100 &#125;; printStudent(&amp;stu); system(&quot;pause&quot;); return 0;&#125; 8.8 结构体案例8.8.1 案例1案例描述： 学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下 设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员 学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值 最终打印出老师数据以及老师所带的学生数据。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Student&#123; string name; int score;&#125;;struct Teacher&#123; string name; Student sArray[5];&#125;;void allocateSpace(Teacher tArray[] , int len)&#123; string tName = &quot;教师&quot;; string sName = &quot;学生&quot;; string nameSeed = &quot;ABCDE&quot;; for (int i = 0; i &lt; len; i++) &#123; tArray[i].name = tName + nameSeed[i]; for (int j = 0; j &lt; 5; j++) &#123; tArray[i].sArray[j].name = sName + nameSeed[j]; tArray[i].sArray[j].score = rand() % 61 + 40; &#125; &#125;&#125;void printTeachers(Teacher tArray[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; tArray[i].name &lt;&lt; endl; for (int j = 0; j &lt; 5; j++) &#123; cout &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl; &#125; &#125;&#125;int main() &#123; srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt; Teacher tArray[3]; //老师数组 int len = sizeof(tArray) / sizeof(Teacher); allocateSpace(tArray, len); //创建数据 printTeachers(tArray, len); //打印数据 system(&quot;pause&quot;); return 0;&#125; 8.8.2 案例2案例描述： 设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。 通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。 五名英雄信息如下： 12345&#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,&#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,&#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,&#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,&#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;, 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//英雄结构体struct hero&#123; string name; int age; string sex;&#125;;//冒泡排序void bubbleSort(hero arr[] , int len)&#123; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j].age &gt; arr[j + 1].age) &#123; hero temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;//打印数组void printHeros(hero arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl; &#125;&#125;int main() &#123; struct hero arr[5] = &#123; &#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;, &#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;, &#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;, &#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;, &#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;, &#125;; int len = sizeof(arr) / sizeof(hero); //获取数组元素个数 bubbleSort(arr, len); //排序 printHeros(arr, len); //打印 system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://space.mearc.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"}]},{"title":"Python安装","slug":"PycharmInstall","date":"2022-12-10T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/11/PycharmInstall/","link":"","permalink":"https://space.mearc.top/2022/12/11/PycharmInstall/","excerpt":"","text":"Python安装下载地址：https://www.python.org/PyCharm安装下载地址：https://www.jetbrains.com/pycharm/ windows:执行下载的安装安装包配置Python的环境变量如图： liunx执行命令：安装Python1sudo apt install python 安装PyCharm12sudo apt updatesudo apt install pycharm-community 设置PyCharm设置解释器 安装插件： 添加软件包选项中设置第三方源： -i https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣: http://pypi.douban.com/simple/阿里云 http://mirrors.aliyun.com/pypi/simple/清华大学: https://pypi.tuna.tsinghua.edu.cn/simple中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://space.mearc.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://space.mearc.top/tags/Python/"}]},{"title":"你好，Qt!","slug":"Qt-HelloWorld","date":"2022-12-10T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/11/Qt-HelloWorld/","link":"","permalink":"https://space.mearc.top/2022/12/11/Qt-HelloWorld/","excerpt":"","text":"你好 Qt在Qt Creator中创建一个图形用户界面的项目，从而生成一个可以显示Hello World字符串的程序。 1.创建程序 2.输入项目名称和创建路径 3.选择构建方式有QMake、CMake等构建方式，本次采用QMake的构建模式。 4. 设置类信息 5. 选择构建方式 6.选择版本构建系统如有需求，需要安装Git等工具。 最后点击完成。 文件说明项目建立完成后会直接进入编辑模式。界面的右边是编辑器，可以阅读和编辑代码。如果觉得字体太小，则可以使用快捷键Ctrl+“十”（即同时按下Ctrl键和十号键）来放大字体，使用Ctrl十“一”（减号）来缩小字体，或者使用Ctrl键十鼠标滚轮，使用Ctl十0（数字）可以使字体还原到默认大小。再来看左边侧边栏，其中罗列了项目中的所有文件。 文件 说明 helloworld.pro 该文件是项目文件，其中包含了项目相关信息 更详细的说明 helloworld.pro.user 该文件中包含了与用户有关的项目信息 helloworld.h 该文件是新建的helloworld类的头文件 helloworld.cpp 该文件是新建的helloworld类的源文件 main.cpp 该文件中包含了main()主函数 helloworld.ui 该文件是设计师设计的界面对应的界面文件 界面设计双击Ui文件，进入设计模式。 添加控件，拖动Label控件到主设计界面，双击主界面的Lable控件，修改显示文本或在属性框中修改text属性。 运行与发布运行可以使用快捷键Ctrl+R或者通过按左下角的运行按钮来运行程序。如果是第次使用，则会弹出“保存修改”对话框，这是因为刚才在设计模式更改了界面，而helloWorld.ui文件被修改了但是还没有保存。现在要编译运行该程序，就要先保存所有文件。可以选中“构建之前总是先保存文件”选项，则以后再运行程序时就可以自动保存 再看一下项目目录中的文件可以发现，E:\\Code\\build-HelloWorld-Desktop_Qt_5_15_2_MinGW_32_bit-Debug\\debug目录下又多了一个build-HelloWorld-Desktop_Qt_5_15_2_MinGW_32_bit-Debug文件夹，这是默认的构建目录。也就是说，Qt Creator将项目源文件和编译生成的文件进行了分类存放，helloworld文件夹中是项目源文件，这个文件夹存放的是编译后生成的文件。进人该文件夹可以看到，这里有3个Makefile文件和一个ui_helloworld.h文件，还有两个目录debug和release,如图2-8所示。release文件夹是空的，进入debug文件夹，有3个.o文件和一个.cpp文件，它们是编译时生成的中间文件，可以不必管它，而剩下的一个helloworld.exe文件便是生成的可执行文件。 双击直接运行HelloWorld.exe程序会报错 警告对话框，提示缺少Qt5 Cored.dl等文件，可以想到应用程序运行是需要dl动态链接库的，可以去Qt的安装目录下寻找该文件。 方法一：在Qt安装的bin目录下复制到与exe程序同一目录下。 方法二：设置把Qt的bin路径添加到环境变量中。 发布1.生成Release程序 切换后，构建一个新目录 E:\\Code\\build-HelloWorld-Desktop_Qt_5_15_2_MinGW_32_bit-Release 打开release文件夹。如何在其他电脑运行程序呢？ 如果要使Release版本的程序可以在别人的计算机上运行（当然，对方计算机也要是Windows平台)，还需要将几个dll文件与其一起发布。可以在桌面上新建一个文件夹，重命名为“我的第一个Qt程序”，然后将release文件夹中的helloworld,exe复制过来，再去Qt安装目录的bin目录中将libgcc_sdw2-l.dll、libstdc++一6.dll、libwinpthread-1.dl、Qt5Core.dll、Qt5Gui.dll和Qt5 Widgets.dll这6个文件复制过来。另外，还需要将plugins目录中的platforms文件夹复制过来（不要修改该文件夹名称），里面只需要保留qwindows.dl文件即可。现在整个文件夹一共有19.3MB,如果使用WinRAR等打包压缩软件对它进行压缩，就只有6MB了，已经到达了可以接受的程度，这时就可以将压缩包发布出去了。Liunx平台也是将.so等文件复制到同一目录，打包成zip文件发布即可。 另外，Qt提供了一个windeployqt(仅Windows平台)工具来自动创建可部署的文件夹。例如，生成的release版本可执行文件在E:\\Code\\exe文件夹中，则只需要在开始菜单的Qt5.15.2菜单中启动Qt的CMD命令行工具，然后输入下面命令即可： 1windeployqt.exe E:\\Code\\exe\\HelloWorld.exe 此方法会拉取很多不需要的dll,如果存在多个版本的Qt还会存在windeployqt可能会拉取错误的path路径下的dll，保留一个路径即可。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://space.mearc.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://space.mearc.top/tags/Qt/"}]},{"title":"Qt Creator Windows安装","slug":"Qt-WindowsInstall","date":"2022-12-10T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/11/Qt-WindowsInstall/","link":"","permalink":"https://space.mearc.top/2022/12/11/Qt-WindowsInstall/","excerpt":"","text":"介绍Qt Creator是一个跨平台的、完整的Qt集成开发环境(IDE),其中包括了高级C++代码编辑器、项目和生成管理工具、集成的上下文相关的帮助系统、图形化调试器、代码管理和浏览工具等。Qt Creator其他功能介绍可以参考Qt开源社区(www.qter.org)书籍页面相应的网络教程。 安装1. 下载地址 官网下载地址：https://download.qt.io/ 2. 安装 选择需要安装的版本（5.15没有安装包），我选择5.12.12打开地址如下：official_releases/qt/5.12/5.12.12/qt-opensource-windows-x86-5.12.12.exe ,其他版本可以返回上层选择。 直达地址：https://download.qt.io/official\\_releases/qt/5.12/5.12.12/ 3. 注册用户打开安装程序，登录Qt账号,没有可以注册，然后下一步，安装位置不建议安装在C盘，文件较大 4. Visual Studio 扩展选择需要安装的组件如果使用 Visual Studio 建议选择 MSVC组件，然后安装，之后就是等待安装完成。 更多更丰富的功能可以参考下面这个图： 在选择组件界面可以选择安装一些模块，为了开发桌面应用可选MinGW、MSVC、UWP其中一个或多个、Android应用要选和Android、Web开发则需要 WebAssembly（在Qt中并不成熟，目前还存在诸多问题）。 MinGW即Minimalist GNU For Windows,是将GNU开发工具移植到Win32平台下的产物，是一套Windows上的GNU工具集，用其开发的程序不需要额外的第三方DLL支持就可以直接在Windows下运行。 MSVC：使Qt可以在 Visual Studio 中开发的一套动态库。 Qt WebEngine 模块提供了一个Web浏览器引擎，可以轻松地将万维网上的内容嵌入到没有本机Web引擎的平台上的Qt应用程序中。Qt WebEngine基于Chromium项目。 Qt Charts、Qt Data Visualization，后期图表绘制和数据可视化内容需要用到。 Qt Installer Framework是 Qt 官方出品的一款功能强大的打包工具。 CMake 是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。是目前主流的跨平台编译工具。 Ninga是Google的一名程序员推出的注重速度的构建工具，一般在Unix/Linux上的程序通过make/makefile来构建编译，而Ninja通过将编译任务并行组织，大大提高了构建速度。 Openssl是一个安全套接字层密码库，囊括主要的密码算法、常用密钥、证书封装管理功能及实现ssl协议。 5. 环境变量设置Windows环境变量设置（VS或Qt Creator 不能正确识别时，可以参考配置） windows-&gt;高级系统设置-&gt;环境变量 ： Path中添加安装程序路径，根据需要添加 6.安装Qt Visual Studio Tools 工具Visual Studio中支持Qt (不需可跳过) ,以 Visual Studio 2022 为例，在管理扩展中安装Qt Visual Studio Tools 工具 也可以在Qt官网下载Visual Studio 插件： 链接直达：https://download.qt.io/official_releases/vsaddin/2.8.1/ 7.在Qt Visual Studio Tools 添加版本信息 安装完成1.验证是否安装成功选择“工具→选项”菜单项，然后选择“构建和运行”项，就可以看到构建套件中已经自动检测到了Qt版本、编译器和调试器。 2.选择一个示例运行2.1 点击示例，输入dialog,选择如图所示项目 2.2 选择配置，点击配置项目 2.3 点击构建 能够运行则说明安装成功 镜像库Qt 临时储存库（各国镜像站点：https://download.qt.io/static/mirrorlist/） 清华大学 ：https://mirrors.tuna.tsinghua.edu.cn/qt/online/qtsdkrepository/windows\\_x86/root/qt/ 上海交通大学: https://mirrors.sjtug.sjtu.edu.cn/qt/online/qtsdkrepository/windows_x86/root/qt/ 中国科学技术大学：https://mirrors.ustc.edu.cn/qtproject/online/qtsdkrepository/windows_x86/root/qt/ 注意：精确到 qt/online/qtsdkrepository/windows_x86/root/qt/ （注意选择对应的操作系统）","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://space.mearc.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://space.mearc.top/tags/Qt/"},{"name":"Windows","slug":"Windows","permalink":"https://space.mearc.top/tags/Windows/"}]},{"title":"Qt Pro文件简单说明","slug":"Qt-pro","date":"2022-12-10T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/11/Qt-pro/","link":"","permalink":"https://space.mearc.top/2022/12/11/Qt-pro/","excerpt":"","text":"介绍QMake 工具有助于简化跨不同平台的开发项目的构建过程。它自动生成文件，因此创建每个生成文件只需要几行信息。您可以将 QMake 用于任何软件项目，无论它是否使用 Qt 编写。 一般情况下， Qt 项目都包含一个后缀名为.pro、名称和项目名相同的文件，我们通常称它为项目管理文件或者工程管理文件（简称 pro 文件），除 pro文件外，还有pri文件进行辅助管理。 Qt官方文档：https://doc.qt.io/archives/qt-5.9/qmake-manual.html 模板示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 构建应用，除此外还能生成静态库或动态库TEMPLATE = app#TEMPLATE = lib#CONFIG += staticlib# 开启则生成静态库# 目标名称，一般和项目名称相同TARGET = helloworld# 添加Qt模块QT += core gui widget webview# 使用预编译头CONFIG += console precompile_headerPRECOMPILED_HEADER = stable.h# 添加头文件HEADERS += hello.h# 添加源文件SOURCES += hello.cpp# 文件判断是否存在!exists( main.cpp ) &#123; error( &quot;No main.cpp file found&quot; )&#125;# 平台区分win32 &#123; SOURCES += hellowin.cpp&#125;unix &#123; SOURCES += hellounix.cpp&#125;# 嵌套作用域和冒号连接符连用win32:debug &#123; CONFIG += console&#125;# 根据目标平台自定义构建目标的名称CONFIG(debug, debug|release) &#123; mac: TARGET = $$join(TARGET,,,_debug) win32: TARGET = $$join(TARGET,,d)&#125;# 添加资源文件RESOURCES += qml.qrc# 使用第三方库# 添加库目录路径INCLUDEPATH += 3rdparty/CatWhisperer/include# 添加库文件 注意：仅当路径包含空格时才需要双引号 -L和 -l省略文件扩展名，方便在不同平台添加第三方库LIBS += -L&quot;3rdparty/CatWhisperer/lib&quot; -lCatWhisperer# 目标目录DESTDIR = bin# 添加子目录SUBDIRS = tool.pri\\ mystatic.pro# 设置应用图标RC_ICONS = appicon.ico","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://space.mearc.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://space.mearc.top/tags/Qt/"}]},{"title":"Qt 工具简单介绍","slug":"Qt-tool","date":"2022-12-10T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/11/Qt-tool/","link":"","permalink":"https://space.mearc.top/2022/12/11/Qt-tool/","excerpt":"","text":"Qt Creator1. 菜单文件菜单。其中，包含了新建、打开和关闭项目和文件、打印文件和退出等基本功能菜单。编辑菜单。这里有撤销、剪切、复制、查找和选择编码等常用功能菜单，高级菜单中还有标示空白符、折叠代码、改变字体大小和使用vim风格编辑等功能菜单。构建菜单。包含构建和运行项目等相关的菜单。调试菜单。包含调试程序等相关的功能菜单。Analyze菜单。包含QML分析器、Valgrind内存和功能分析器等相关菜单。工具菜单。这里提供了快速定位菜单、外部工具菜单等。这里的选项菜单中包含了Qt Creator各个方面的设置选项：环境设置、文本编辑器设置、帮助设置构建和运行设置、调试器设置和版本控制设置等。在环境设置的Interface页面可以将主题Theme设置为Classic,这样就可以使用以前的经典Qt Creator主题了。控件菜单。包含了设置窗口布局的一些菜单，如全屏显示和隐藏边栏等。帮助菜单。包含Qt帮助、Qt Creator版本信息、报告bug和插件管理等菜单。 1. 模式Qt Creator包含欢迎、编辑、设计、调试(Debug)、项目和帮助6个模式，各个模式完成不同的功能，也可以使用快捷键来更换模式，各自对应的快捷键依次是Cr1十数字1~6。 欢迎模式欢迎模式，主要提供了一些功能的快捷入口，如打开帮助教程、打开示例程序、打开项目、新建项目、快速打开以前的项目和会话、联网查看Qt官方论坛和博客等。Projects页面显示了最近打开的项目列表，在这里也可以创建一个新项目或者打开一个已有项目；示例页面显示了Qt自带的大量示例程序，并提供了搜索栏从而实现快速查找；教程页面提供了一些视频教程资源。 编辑模式编辑模式，其主要用来查看和编辑程序代码，管理项目文件。Qt Creator中的编辑器具有关键字特殊颜色显示、代码自动补全、声明定义间快捷切换、函数原型提示、F1键快速打开相关帮助和全项目中进行查找等功能。也可以在“工具→选项”菜单项中对编辑器进行设置。 设计模式设计模式，这里整合了Qt设计师的功能。可以设计图形界面，进行部件属性设置、信号和槽设置、布局设置等操作。如果是在Qt Quick项目中，还可以激活Quck设计器，那是全新的设计器界面。可以在“工具→选项”菜单项中对设计师进行设置。 调试模式调试模式，支持设置断点、单步调试和远程调试等功能，包含局部变量和监视器、断点、线程以及快照等查看窗口。可以在“工具→选项”菜单项中设置调试器的相关选项。 项目模式项目模式，包含对特定项目的构建设置、运行设置、编辑器设置、代码风格设置和依赖关系等页面。构建设置中可以对项目的版本、使用的Qt版本和编译步骤进行设置：编辑器设置中可以设置文件的默认编码：在代码风格设置中可以设置自己的代码风格。也可以在“工具→选项”菜单项中对项目进行设置。 帮助模式帮助模式，在帮助模式中将Qt助手整合了进来，包含目录、索引、查找和书签等几个导航模式，可以在帮助中查看Qt和Qt Creator的各方面信息。可以在“工具→选项”菜单中对帮助进行相关设置。 其他窗口 按下F1 可以打开帮助模式，快速打开某个类的文档 定位器切换 Qt Creator配置一般情况下无需修改Qt默认配置，安装Qt后会自动连接。 Qt Assistant(Qt助手)Qt Assistant是可配置且可重新发布的文档阅读器，可以方便地进行定制，并与Qt应用程序一起重新发布。它的功能有： 定制Qt Assistant并与应用程序一起重新发布。快速查找关键词、全文本搜索、生成索引和书签。同时为多个帮助文档集合建立索引并进行搜索。在本地存放文档或在应用程序中提供在线帮助。 Qt Designer(Qt设计师)Qt Designer是强大的跨平台GUI布局和格式构建器。由于使用了与应用程序中将要使用的相同部件，可以使用屏幕上的格式快速设计、创建部件以及对话框。使用Qt Designer创建的界面样式功能齐全并可以进行预览，这样就可确保其外观完全符合要求。功能和优势有： 使用拖放功能快速设计用户界面。定制部件或从标准部件库中选择部件。以本地外观快速预览格式。通过界面原型生成C十十、Java或Python代码。将Qt Designer与Visual Studio或Eclipse IDE配合使用。使用Qt信号与槽机制构建功能齐全的用户界面。 Qt Linguist(Qt语言家)Qt Linguist提供了一套加速应用程序翻译和国际化的工具。Qt使用单一的源码树和单一的应用程序二进制包就可以同时支持多个语言和书写系统。主要功能有： 收集所有UI文本，并通过简单的应用程序提供给翻译人员。语言和字体感知外观。通过智能的合并工具快速为现有应用程序增加新的语言。Unicode编码支持世界上大多数字母。运行时可切换从左向右或从右向左的语言。在一个文档中混合多种语言。可以使用Qt Linguist来使应用程序支持多种语言。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://space.mearc.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://space.mearc.top/tags/Qt/"}]},{"title":"文章模板","slug":"hello-world","date":"2022-12-03T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/04/hello-world/","link":"","permalink":"https://space.mearc.top/2022/12/04/hello-world/","excerpt":"","text":"标题一1. 小标题一 正文…","categories":[{"name":"模板","slug":"模板","permalink":"https://space.mearc.top/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://space.mearc.top/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Qt 静态编译","slug":"Qt-StaticCompile","date":"2022-12-01T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/02/Qt-StaticCompile/","link":"","permalink":"https://space.mearc.top/2022/12/02/Qt-StaticCompile/","excerpt":"","text":"Windows环境 - 静态编译：准备阶段安装 Visual Studio 2022、安装Qt5.15.2动态库版本 安装python3、安装Perl、安装Ruby； 下载Perl: https://strawberryperl.com/releases.html下载Ruby: https://github.com/oneclick/rubyinstaller2/releases/tag/RubyInstaller-3.0.3-1下载源码：https://download.qt.io/archive/qt/5.15/5.15.2/single/ 添加Perl、Python、Ruby以及gnuwin32到Path环境变量（gnuwin32工具包含在QT源文件根目录下）：修改源码qt-everywhere-src-5.15.0\\qtbase\\mkspecs\\common\\msvc-desktop.conf配置将 123QMAKE_CFLAGS_RELEASE = $$QMAKE_CFLAGS_OPTIMIZE -MDQMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_OPTIMIZE -Zi -MDQMAKE_CFLAGS_DEBUG = -Zi –MDd 改为 123QMAKE_CFLAGS_RELEASE = $$QMAKE_CFLAGS_OPTIMIZE -MTQMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_OPTIMIZE -Zi -MTQMAKE_CFLAGS_DEBUG = -Zi -MTd PS: D的意思是动态编译(dynamic link)，T的意思是静态编译（static link） MSVC32编译使用 x86 Native Tools Command Prompt for VS 2022 工具进行编译 MSVC64编译使用x64 Native Tools Command Prompt for VS 2022 CurrentPS：编译32位库和64位库只有此处不同输入命令： 1configure -confirm-license -opensource -platform win32-msvc -debug-and-release -static -static-runtime -force-debug-info -opengl dynamic -prefix &quot;E:/QT5.15.2_Static/msvc_32&quot; -qt-sqlite -qt-pcre -qt-zlib -qt-libpng -qt-libjpeg -opengl desktop -qt-freetype -nomake tests -no-compile-examples -nomake examples -prefix 代表构建目录，是编译完成后，头文件和库文件的输出路径，建议这里的文件夹名全英文，否则可能会在最后nmake install 报copy命令语法不正确的错误-shared -static 表示生成动态或静态库，不指定此参数默认是动态库-release 生成release发布版，或指定 -debug调试版-nomake 指定不编译输出的子文件夹-skip 指定跳过编译的子模块-opensource 表示编译开源版本，相对的是 -commercial ，表示编译商业版本-confirm-license 表示确认许可协议 编译动态库输入（无需修改配置文件） 1configure -confirm-license -opensource -platform win32-msvc -debug-and-release -shared -force-debug-info -opengl dynamic -prefix &quot;E:/QT5.15.2_S/msvc_32&quot; -qt-sqlite -qt-pcre -qt-zlib -qt-libpng -qt-libjpeg -opengl desktop -qt-freetype -nomake tests -no-compile-examples -nomake examples 编译文件生成后进行编译，输入执行完成后输入nmake执行完成后输入nmake install 编译完成后添加到Qt Versions 添加Kit 编译套件PS:红色方框部分，添加的Compiler要和编译用的一致 MingW32编译1.占用控件较大，预计75G或者更多2.设置环境变量3.创建一个脚本文件名为build_env.bat以下内容复制到该脚本文件中 123456set PATH=D:\\QT\\Tools\\mingw810_32\\bin;D:\\QT\\Tools\\mingw810_32\\opt\\bin;E:\\tool\\QT-5.15.2\\src\\qt-everywhere-src-5.15.0\\gnuwin32\\bin;C:\\WINDOWS\\System32;C:\\Windows\\System32\\WindowsPowerShell\\v1.0;C:\\Windows\\System32\\wbem;C:\\WINDOWSset LANG=enset QT_INSTALL_PREFIX= E:\\tool\\QT-5.15\\mingw_32cmd /k 在源码文件夹建一个build文件夹，切换到build文件夹中，编译静态库： 1..\\configure.bat -confirm-license -opensource -platform win32-g++ -debug-and-release -static -static-runtime -force-debug-info -opengl dynamic -prefix &quot;E:/tool/Qt5.15.2/mingw_32&quot; -qt-pcre -qt-zlib -qt-libpng -qt-libjpeg -opengl desktop -qt-freetype -nomake tests -no-compile-examples -nomake examples 编译动态库 1..\\configure.bat -confirm-license -opensource -platform win32-g++ -debug-and-release -static -static-runtime -force-debug-info -opengl dynamic -prefix &quot;E:/tool/Qt5.15.2/mingw_32&quot; -qt-pcre -qt-zlib -qt-libpng -qt-libjpeg -opengl desktop -qt-freetype -nomake tests -no-compile-examples -nomake examples 编译文件生成完成后输入：执行 mingw32-make执行 mingw32-make install Liunx_AMD64环境：(没有版本要求可以直接在Qt下载安装)下载源码，同windows源码下载一样解压源码 1tar xvf qt-everywhere-src-5.15.2.tar.xz 创建一个安装位置 1mkdir Qt5.15.2_Static 安装编译环境: 1234sudo apt-get build-dep qt5-defaultsudo apt-get install libxcb-xinerama0-devsudo apt-get install build-essential perl python gitsudo apt-get install &#x27;^libxcb.*-dev&#x27; libx11-xcb-dev libglu1-mesa-dev libxrender-dev libxi-dev 创建编译脚本（debug）： 1./configure -prefix /home/Qt5.15.2_Static -debug -opensource -confirm-license -no-openssl -no-opengl -qt-xcb -skip qtquickcontrols -skip qtquickcontrols2 -skip qtsensors -skip qtdoc -no-compile-examples 创建编译脚本（release ）： 1./configure -prefix /home/Qt5.15.2_Static -release -opensource -confirm-license -no-openssl -no-opengl -qt-xcb -skip qtquickcontrols -skip qtquickcontrols2 -skip qtsensors -skip qtdoc -no-compile-examples 参数：prefix 是一会儿install的路径，如果不制定，就会安装到默认的/usr/local/ 下debug 是编译debug版本的Qtopensource 是选定开源版本confirm-license 是确定下协议创建编译文件完成开始编译安装终端执行：make -j4make installPS：-j4 代表电脑CPU核心,核心越多编译越快 Liunx_ARM环境：(没有版本要求可以直接应用商店下载安装Qt5)安装编译环境sudo apt-cache search aarch64其他和Liunx_AMD 一致 常见问题就是 一般是缺少依赖，或者版本过低，建议升级依赖项的版本 ####参考文章Qt源码编译configure参数列表：https://blog.csdn.net/qq_37654240/article/details/109639331wget软件下载：https://www.freedesktop.org/software/Qt官方源码编译说明：https://doc.qt.io/qt-5/linux-building.html","categories":[{"name":"源码编译","slug":"源码编译","permalink":"https://space.mearc.top/categories/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://space.mearc.top/tags/Qt/"},{"name":"Windows","slug":"Windows","permalink":"https://space.mearc.top/tags/Windows/"}]},{"title":"Qt Creator Liunx（Ubuntu）安装","slug":"Qt-LiunxInstall","date":"2022-11-30T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/12/01/Qt-LiunxInstall/","link":"","permalink":"https://space.mearc.top/2022/12/01/Qt-LiunxInstall/","excerpt":"","text":"使用特定版本的Qt和GCC进行安装1.安装编译环境1sudo apt-get install build-essential 2.安装GCC71sudo apt-get install gcc-7 3.安装G++1sudo apt-get install g++-7 4.设置软链接（默认链接）123ln -s /usr/bin/gcc-7 /usr/bin/gcc -fln -s /usr/bin/gcc-ar-7 /usr/bin/gcc-ar -fln -s /usr/bin/g++-7 /usr/bin/g++ -f 5.安装Qt1sudo apt-get install qt5-default 6.安装通用字体配置库1sudo apt-get install libfontconfig1 7.安装OpenGL库12sudo apt-get install mesa-common-devsudo apt-get install libglu1-mesa-dev -y 8.设置文件关联1[Desktop Entry] Version=1.0 Encoding=UTF-8 Type=Application Name=QtCreator Comment=QtCreator NoDsiplay=true Exec=(Install folder of QT)/Tools/QtCreator/bin/qtcreator %f Icon=(Install folder of QT)/5.4/Src/qtdoc/doc/images/landing/icon_QtCreator_78x78px.png Name[en_US]=Qt-Creator 9.安装CMake1sudo apt-get install cmake 10.安装Git1sudo apt-get install git 11.安装gdb1sudo apt-get install gdb 12.安装Qt IDE1sudo apt-get install qtcreator 13.下载qt5.14.2 .run （AMD64）安装包ARM版本安装需要自己编译链接直达：https://download.qt.io/archive/qt/5.14/5.14.2/PS：之后的版本不在提供安装包","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://space.mearc.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://space.mearc.top/tags/Qt/"},{"name":"Liunx","slug":"Liunx","permalink":"https://space.mearc.top/tags/Liunx/"}]},{"title":"Git的使用方法","slug":"Git-Basic","date":"2022-11-28T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/11/29/Git-Basic/","link":"","permalink":"https://space.mearc.top/2022/11/29/Git-Basic/","excerpt":"","text":"git常用命令 命令名称 作用 git config –global user.name 用户名 设置用户签名 git config –global user.name 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 文件名 添加到暂存区 git commit -m ‘日志信息’ 文件名 提交到本地库 git reflog 查看历史记录 git rest –hard 版本号 版本穿梭 初始化本地库 git init 查看本地库状态 git status 添加暂存区 git add 文件名 删除暂存区文件 git rm –cached 文件名 提交本地库 git commit -m ‘first commit’ 文件名 穿梭版本号通过git reflog 查看版本号，然后使用git reset –hard 版本号 分支操作 命令名称 作用 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定 的分支合并到当前分支上 git checkout -b 新分支名称 在当前分支创建一个新的分支 合并冲突合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改，git无法决定，必须人为决定新代码内容。 打开文件进行手动修改 再进行添加暂存区，提交本地库，不要带文件名 git commint -m ‘ ‘ GitHub操作远程仓库操作 命令名称 作用 git remote -v 查看当前所有远程地址别名 git remote add 别名 远程地址 起别名 git push 别名 分支 推送本地分支上的内容到远程仓库 git clone 远程地址 将远程仓库的内容克隆到本地 git pull 远程库地址别名 远程分支名 将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并 团队协作添加操作仓库成员 settings-&gt;Collaboraors-&gt;add people 发送链接 fork：将别人仓库拉取到自己仓库 推送到别人仓库：pull requests-&gt;new pull request -&gt;create pull request-&gt;create pull request 申请合并提交申请：Merge pull request-&gt;comfirm merge 免密登录idea集成git配置git忽略文件 创建忽略规则文件 xxxx.ignore(前缀名随便起，建议是git.ignore) 12.log.jar 在.gitconfig文件中引用忽略配置文件（此文件在windows的家目录中） 12[core] excludesfile= C:/User/asus/git.ignore idea初始化本地库 初始化本地库：VCS-&gt;import-&gt;version-&gt;control-&gt;create git repository 添加到暂存区：git-&gt;add commit directory commit idea切换版本右击版本，checkout Revision idea创建分支git-&gt;Repository-&gt;Branches idea合并分支合并到当前分支：右下角点击分支-&gt;merge into current idea合并冲突分支 右下角点击分支-&gt;merge into current merge-&gt;手动选择（左边master，右边分支代码，中间没有冲突的代码） idea代码推送到远程仓库push-&gt;点击中间地址或别名，点击（define remote），输入ssh的url（可以不用设置）-&gt;push 注意：push是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push的操作是会被拒绝的。也就是说，想要铺设成功，一定要保证本地库的版本要比远程库的版本高。如果本地库的代码版本已经落后，切记要先pull拉取一下远程库的代码，将本地代码更新到最新后，然后再修改，提交，推送 远程拉取1git pull 拉取子模块首次克隆仓库及其模块 1git clone --recursive https://XXX 首次拉取模块 12345git submodule update --init --recursive// 更新单个子模块xxxgit submodule update --init xxx 更新子模块 1234567// 适用于git 1.8.2及以上版本git submodule update --recursive --remote// 适用于git 1.7.3及以上版本git submodule update --recursive//或者git pull --recurse-submodules 注意：pull是拉取远端仓库代码到本地，如果远程代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手都冻解决冲突的问题。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://space.mearc.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://space.mearc.top/tags/Git/"}]},{"title":"Hexo 更新方法","slug":"HexoUpdateDoc","date":"2022-11-24T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"2022/11/25/HexoUpdateDoc/","link":"","permalink":"https://space.mearc.top/2022/11/25/HexoUpdateDoc/","excerpt":"","text":"此教程使用于本网站文档更新前提条件：云服务器中安装Hexo并配置文件,并将Blog同步到GitHub或Gitee。Hexo安装配置 可移步 Hexo安装配置 1.在GitHub或Gitee中 [source/_posts /] 下添加md文件2.服务器拉去GitHub或Gitee中的项目即可","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://space.mearc.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://space.mearc.top/tags/Hexo/"}]}],"categories":[{"name":"ODA","slug":"ODA","permalink":"https://space.mearc.top/categories/ODA/"},{"name":"编程语言","slug":"编程语言","permalink":"https://space.mearc.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工具使用","slug":"工具使用","permalink":"https://space.mearc.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"源码编译","slug":"源码编译","permalink":"https://space.mearc.top/categories/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"name":"网络通信","slug":"网络通信","permalink":"https://space.mearc.top/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"模板","slug":"模板","permalink":"https://space.mearc.top/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://space.mearc.top/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://space.mearc.top/tags/Qt/"},{"name":"设计模式","slug":"设计模式","permalink":"https://space.mearc.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"nginx","slug":"nginx","permalink":"https://space.mearc.top/tags/nginx/"},{"name":"CSS","slug":"CSS","permalink":"https://space.mearc.top/tags/CSS/"},{"name":"VPS","slug":"VPS","permalink":"https://space.mearc.top/tags/VPS/"},{"name":"Python","slug":"Python","permalink":"https://space.mearc.top/tags/Python/"},{"name":"Windows","slug":"Windows","permalink":"https://space.mearc.top/tags/Windows/"},{"name":"模板","slug":"模板","permalink":"https://space.mearc.top/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"Liunx","slug":"Liunx","permalink":"https://space.mearc.top/tags/Liunx/"},{"name":"Git","slug":"Git","permalink":"https://space.mearc.top/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://space.mearc.top/tags/Hexo/"}]}