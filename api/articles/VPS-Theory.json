{"title":"VPS原理及搭建方法","slug":"VPS-Theory","date":"2022-12-11T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"api/articles/VPS-Theory.json","excerpt":null,"covers":["https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png","https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.png","https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/%E7%BF%BB%E5%A2%99%E5%8E%9F%E7%90%86.png","https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/image-20221212221930138.png"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"01-网络通信的基本过程\"><a href=\"#01-网络通信的基本过程\" class=\"headerlink\" title=\"01 网络通信的基本过程\"></a>01 网络通信的基本过程</h1><p><img src=\"https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png\" alt=\"网络通信基本流程\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.png\" alt=\"网络通信原理\"></p>\n<p>我们在浏览器中输入baidu.com这个网址，我们的网络是通过ip来定位某一台服务器的，域名仅仅是一串字符串，他绑定了一个ip地址。这个ip地址是找dns服务器获取。但是一开始不是直接去找dns服务器。</p>\n<p>首先他会检查浏览器的缓存还有本地的缓存，里面有没有他的域名，如果浏览器里没有缓存就会检查本地的hosts文件，看看文件里面有没有添加映射关系。如果hosts文件里面也没有就会将请求发送到电脑配置的dns服务器上。</p>\n<ol>\n<li><p>怎么发送到dns的服务器上去的？</p>\n<p>首先要了解一下OSI的七层模型</p>\n<p>首先输入baidu.com，浏览并没有得到本地的百度ip地址，所以说他就会将请求发送到dns服务器上 </p>\n<p>dns是一个<strong>应用层</strong>的协议，<strong>它主要就是用来获取域名所绑定的ip地址</strong>，当传到应用层就会<strong>构造一个相关的协议</strong>，这个协议会生成一个相关的请求。然后，他要通过OSI模型一层一层往下传到<strong>物理层</strong>，也就是网卡的接口。生成请求数据之后，会传到<strong>传输层</strong>，他会对应用层的数据进行封装，他封装了一个源端口和目标端口，比如源端口404，目标端口，dns默认的是53号端口。然后将应用层传过来的协议和端口封装成一个<strong>数据包</strong>，然后接着往下传。<strong>传输层</strong>主要是有<strong>端口</strong>这个概念。</p>\n<p>接下来来到<strong>网络层</strong>，网络层在前面也会<strong>封装一个包头</strong>，也就是源ip和目标ip，本机的电脑ip和你要访问的服务器ip，比如本机IP192.168.1.20 和dns服务器地址8.8.8.8。将和之前的数据封装号之后发送到链路层。网络层主要会<strong>添加ip地址</strong>。网络层封装数据之后，发现目标的ip地址并不在我的网段范围之内，找不到ip地址，接下里他就会去找网关。家里的<strong>网关一般是路由器</strong>。这里就可以将请求发送给网关。在同一个局域网里面通信，使用的mac地址，数据将会来到下一层。准备发往网关数据里。</p>\n<p><strong>数据链路层</strong>会在前面加上网关的mac地址和你的源mac地址。通过ARP协议来获取到网关的cc的mac地址。</p>\n<p>接着，这条数据就会顺着<strong>物理层</strong>来到网卡的接口，他就会通过网卡从网线中发出去，来到了交换机的位置。</p>\n<p><strong>交换机他是一个二层的设备</strong>，也就是说他只能<strong>解析两层的数据</strong>。数据包从网卡来到交换机，交换机收到数据之后，看一下它里面的mac地址，源mac地址，接着，就将数据包转发到路由器mac地址为cc的这个端口。（路由器是一个三层设备，所以说它能解析三层的数据）。<strong>数据到达路由器端口之后</strong>，传到数据链路层，<strong>发现mac地址和我一样就会把它拿掉</strong>，然后就收这个数据包，接受之后就会把它的头部拿掉，拿掉之后在往上传，传到网络层，源ip地址和目标IP地址，发现没有8.8.8.8直接链接，那么路由器，它的工作就是把这个数据在路由出去，转发出去，路由器他会设置一个<strong>默认路由</strong>，当路由器发现找不到8.8.8.8的时候，他就会发送到默认路由，一般来说就直接发送到公网的其他的路由器了，于是他就会把这个数据转发给公网上的其他路由器，他会把我们的数据包从我们的WAN口（路由器中有一个颜色不一样的口，叫做WAN口，他是通往互联忘的道路），<strong>WAN口有一个公网的ip地址</strong>，也就是20.20.20.20，他需要将内网的数据转发出去，这里的话路由器还需要做一个<strong>NAT操作</strong>（网络地址转换）。因为源ip地址是一个内网的的网段，他不能在公网上进行传输，必须转成WAN口允许公网传输的这么一个协议。路由器中有一个<strong>NAT的映射表</strong>，他会先将本地的ip地址保存在在NAT映射表中，源ip地址和源端口放进去，然后将WAN公网ip地址放入网络层数据包的地址中，数据包的端口也会随便生成一个，同时也会在NAT映射表中记录一个他们之间的映射关系。之后路由器就会把数据包的ip和端口改掉，然后再回到数据链路层，然后在加上源mac地址和目标地址（<strong>注意</strong>：源mac地址就是现在的WAN口地址了，目标mac地址就是它的下一条的路由器的mac地址）。最后在来到物理层。最后他这个数据包就会从WAN口出去来到了互联网上的其他路由器，经过十来个路由器，最终找到dns服务器，然后将数据交给这台dns服务器。</p>\n<p>我们知道dns是一个应用层的协议，所以这台服务器也能解析到应用层。</p>\n<p>dns服务器拿到数据包之后，从物理层到数据链路层，解析mac地址正确，拿掉数据包的mac地址，然后在往上传这个数据包，网络层，传输层依旧如此。最后把这个报文发送给应用层的dns应用，dns收到这个请求后。生成一个dns的响应，之后就会沿着OSI模型往回传</p>\n</li>\n<li><p>补充</p>\n<p>在传输层有两个协议一个是tcp，还有一个是udp。我们在应用层这个http的话，他是基于tcp的，我们要发送http请求，必须先使用tcp的方式跟访问的谷歌服务器建立连接，才能发送http请求。</p>\n<p>现在要访问谷歌，得到正确的ip地址之后，我们要先发送一个tcp建立连接的请求 ，比如说，发送一个连接请求，来到传输层，用源端口和目标端口建立连接，一系列操作后，来到物理层发送出去，发现ip不在国内，于是会经过防火墙（GFW），经过防火墙的时候，（这个防火墙强大到可以解析应用层的流量）防火墙里有一个列表，记录了一些黑名单的ip地址或者域名之类的，或者防火墙可以伪装的谷歌服务器，给你返回数据包。（<strong>tcp重置攻击</strong>）</p>\n<p>当与服务器建立连接发送请求后，如果数据包里面有关于google 的信息，GFW也会把它干掉，虽然已经与服务器建立连接，但是数据根本就传不出去</p>\n</li>\n</ol>\n<h1 id=\"02-墙拦截的原理与绕过\"><a href=\"#02-墙拦截的原理与绕过\" class=\"headerlink\" title=\"02 墙拦截的原理与绕过\"></a>02 墙拦截的原理与绕过</h1><p>当浏览器发送一个请求，发送的谷歌服务器，当返回回来之后，GFW会在返回的ip里面动一些手脚，本地收到数据包之后，由应用层解析完毕之后，于是我们就拿到了一个假的IP地址（<strong>DNS污染 ，也可以叫dns劫持</strong>）。</p>\n<p>这个时候我们如果不发送dns请求，他就不会造成dns污染。当我们浏览器访问谷歌的一瞬间，他并不是直接发送dns，而是先检查本地的dns缓存，如果没有再去检查hosts文件。如果hosts文件中有ip和域名的映射关系，当浏览器发起的时候，而是直接找到hosts文件，应为hosts文件里面添加了映射关系，他就会直接使用这个ip，不需要在发送dns请求，去通过dns获取ip地址。</p>\n<p>经过以上集中凡是的拦截，我们的路就会被卡的死死的，我们第一时间想到的就是使用代理进行访问，我们接触最后的代理方式就是http代理和socks5代理。比如我们在vps上搭建一个socks5的服务，监听了一个端口1080，我们就可以构建一个数据包，发往这台vps6.6.6.6 端口1080，和这个端口建立连接。虽然说确实可以正常访问谷歌服务器，也没有经过防火墙，但是<strong>从我们这里发出去就不行</strong>了，比如说，我们发送到防火墙这里，众所周知，防火墙可以解析到应用层，也就是说它可以看到里面的内容， 看到想让vps这台服务器帮你解析谷歌，他又会帮你干掉了</p>\n<ol>\n<li><p>为什么可以如此精确的阻断连接？</p>\n<p>归根结底，我们的意图被它看到了，它可以解析里面的数据内容</p>\n</li>\n<li><p>怎么才能让他看不到里面的内容？</p>\n<p>加密，vpn他就是会加密数据流量的，比如我们经常使用的IPsec，或者openVpn，这些协议他都可以进行对数据加密。那么这种传统的vpn虽然可以进行对数据加密，但是他的特征会非常明显，也就是说虽然防火墙它看不到我们的数据内容，但是它能知道我们在进行vpn连接。</p>\n</li>\n<li><p>那么要怎么做才能既加密流量又没有特征呢？</p>\n<p>shadowsocks，这个协议一出生就是为了绕过防火墙的检查</p>\n<p>假设在vps上搭建一个ss的服务端，它监听一个端口8388，同时我们本机运行一个ss客户端，然后它监听一个端口1080，socks5的端口，同时我们的浏览器设置了一个代理端口，也就是说我们浏览器的访问请求会先走这个代理端口（1080），ip地址就是本机127.0.0.1，就相当于我们在浏览器中发送一个访问谷歌请求的时候，这个请求会转发到本机的1080这个端口， 那么这个端口是由ss的客户端在监听，那么这个请求就会发送到ss的客户端，客户端拿到这个请求，他会对这个请求加密，会把里面的内容加密，加密之后我们是看不到数据包里面的内容，然后就会来到传输层，那么他会从源端口是监听1080，目标端口就是客户端里面配置好的需要连接的服务器（8388），最后由物理层发送出去。防火墙放行通过后，就会路由到vps服务器，服务器拿到数据包，解析8388端口，是ss服务端处理，拿到数据之后进行解密，解密之后就会获得原始的请求，他会代替你访问谷歌，他会从谷歌得到一份响应， 收到数据后，同样也会对数据进行加密，加密之后重新构造一个数据包，返回给客户端，最后客户端会得到这个数据包，ss客户端拿到数据之后将会返回给浏览器，浏览器拿到数据之后就可以愉快的访问了。</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/%E7%BF%BB%E5%A2%99%E5%8E%9F%E7%90%86.png\" alt=\"VPS搭建原理\"></p>\n<h1 id=\"03-节点搭建\"><a href=\"#03-节点搭建\" class=\"headerlink\" title=\"03 节点搭建\"></a>03 节点搭建</h1><p><strong>vps</strong></p>\n<p><strong>虚拟专用服务器</strong>（英语：Virtual private server，缩写为VPS），是将一台<a href=\"https://zh.m.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8\">服务器</a>分割成多个虚拟专用服务器的服务。实现VPS的技术分为<a href=\"https://zh.m.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96\">容器</a>技术和<a href=\"https://zh.m.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA\">虚拟机</a>技术。在容器或虚拟机中，每个VPS都可分配独立公网<a href=\"https://zh.m.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80\">IP地址</a>、独立<a href=\"https://zh.m.wikipedia.org/zh-cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\">操作系统</a>、实现不同VPS间磁盘空间、<a href=\"https://zh.m.wikipedia.org/wiki/%E5%86%85%E5%AD%98\">内存</a>、<a href=\"https://zh.m.wikipedia.org/wiki/CPU\">CPU</a>资源、进程和系统配置的隔离，为用户和<a href=\"https://zh.m.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F\">应用程序</a>模拟出“独占”使用计算资源的体验。VPS可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。VPS为用户提供了管理配置的自由，可用于企业虚拟化，也可以用于<a href=\"https://zh.m.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83\">IDC</a>资源租用。</p>\n<ol>\n<li><p>购买vps服务器</p>\n<p>vultr ：<a href=\"https://www.vultr.com/\">https://www.vultr.com/</a></p>\n<p>第二个相对比较实惠；</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/image-20221212221930138.png\" alt=\"image-20221212221930138\"></p>\n</li>\n<li><p>在Linux下搭建shadonsocks服务端</p>\n<p>shadownsocks相关命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">安装shadowsocks</span></span><br><span class=\"line\">apt install shadowsocks-libev</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看shadowsocks状态</span></span><br><span class=\"line\">systemctl status shadowsocks-libev.service</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">编辑ss配置文件</span></span><br><span class=\"line\">vim /etc/shadowsocks-libev/config.json</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启shadowsocks</span></span><br><span class=\"line\">systemctl restart shadowsocks-libev.service</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看shadowsocks运行日志：</span></span><br><span class=\"line\">journalctl -u shadowsocks-libev.service -f</span><br></pre></td></tr></table></figure>\n\n<p>Ubuntu防火墙设置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看状态</span></span><br><span class=\"line\">ufw status</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">开放端口</span></span><br><span class=\"line\">ufw allow 8388</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">拒绝端口</span></span><br><span class=\"line\">ufw deny 8388</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">删除规则</span></span><br><span class=\"line\">ufw delete allow 8388</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">关闭防火墙</span></span><br><span class=\"line\">ufw disable</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动防火墙</span></span><br><span class=\"line\">ufw enable</span><br></pre></td></tr></table></figure></li>\n<li><p>相关命令解释</p>\n<p>vim /etc/shadowsocks-libev/config.json</p>\n<p>需要将IP地址改成0.0.0.0,改成0的意思是接受所有ip地址往他的8388端口发送数据，默认是只允许本机（127.0.0.1环回地址）的地址发送数据。</p>\n<p>密码需要一样，因为它使用的是对称加密算法，并且加密方式为GCM的格式，这种加密方式是带身份认证的</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;server&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span><span class=\"string\">&quot;::1&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;0.0.0.0&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mode&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;tcp_and_udp&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;server_port&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">8388</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;local_port&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1080</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;password&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;k58LRQwcnKqb&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;timeout&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">86400</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;method&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;chacha20-ietf-poly1305&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;server&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span><span class=\"string\">&quot;::1&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;0.0.0.0&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mode&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;tcp_and_udp&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;server_port&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">8388</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;local_port&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1080</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;password&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;h0rc6ZWBBaRI&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;timeout&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">86400</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;method&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;chacha20-ietf-poly1305&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>重放攻击</strong>：假设电脑生成一个数据包，往服务器上发，其中经过了防火墙，防火墙它也可以拿着你的数据主动往服务器上发送，用你的数据发送，这就是一个重放攻击。它的探测目的就是为了了解你这个服务器上是否运行了某些服务，比如shadowsockes。具体怎么探测到就不得而知了。</p>\n<ol start=\"4\">\n<li><p>相关连接</p>\n<p>SSH连接工具（FinalShell）：<a href=\"https://bulianglin.com/g/aHR0cDovL3d3dy5ob3N0YnVmLmNvbS90Lzk4OC5odG1s\">http://www.hostbuf.com/t/988.html</a><br>SS客户端(shadowsocks-windows)： <a href=\"https://bulianglin.com/g/aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzL3NoYWRvd3NvY2tzLXdpbmRvd3M\">https://github.com/shadowsocks/shadowsocks-windows</a><br>shadowsocks插件(v2ray-plugin)：<a href=\"https://bulianglin.com/g/aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzL3YycmF5LXBsdWdpbg\">https://github.com/shadowsocks/v2ray-plugin</a><br>方便测速但不支持ss插件(v2rayN)：<a href=\"https://bulianglin.com/g/aHR0cHM6Ly9naXRodWIuY29tLzJkdXN0L3YycmF5Tg\">https://github.com/2dust/v2rayN</a></p>\n</li>\n<li><p>Tcpping测试连接显示timeout，也就是没办法和vps进行通讯，这是为什么呢？</p>\n<p>因为服务器上的防火墙没有关，在服务器的外围，其实还有一层防火墙，刚安装好只开放了一个22号端口，也就是说我们从外面往它里面发送数据，他只允许访问22号端口，8388端口是不允许访问的。</p>\n</li>\n</ol>\n<p>在外面发送请求的时候，防火墙马上发送了一个探测包，这个防火墙拿这我们的数据，他也主动往服务器发送了一次，然后我们服务器显示认证失败，但是这个防火墙已经得到了它想要的。他可能在这一次探测当中，就已经知道了你这里已经运行了shadowsocks的服务，虽然说他可能防重放攻击，但是防火墙已经达到的探测目的，当他已经知道你这里运行了shadowsocks的服务的时候，他就会把你们的连接切断。</p>\n<p>既然能被探测那么ss节点是不是没办法用了？理论上来说确实是，但是ss协议引入了plagin功能，它主要的功能就是对数据流量进行伪装，比如说把我们经过ss假币后的数据流量伪装成普通的http或者websocket这种协议的流量。</p>\n<p>首先浏览器会构建一个请求，由于我们设置了系统代理，所以说他会把这个请求发送到配置的系统代理，也就是1080端口，这个数据就会来到ss客户端，因为它监听了客户端，会使用ss客户端的加密方式和密码对请求进行加密，如果没有插件就会直接传到防火墙，但是加了插件，会传到插件这里，他会对这个数据流量进行伪装（比如会伪装成http协议头的头），让防火墙以为我们在访问一个正常的网站，当防火墙发现他只是一个普通的http流量的时候，就可能不会再向服务器发送探测包了。于是数据包就会放行通过，当来到vps时，插件拿到数据的时候会把协议头去掉，之后就把真正的数据发往服务端了。这就是plagin的原理，主要起到了流量伪装的作用。</p>\n<p>ssr节点就是类似加了插件的ss节点</p>\n<ul>\n<li>服务端安装plugin插件</li>\n</ul>\n<p><code>apt install shadowsocks-v2ray-plugin  </code></p>\n<p>修改配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:[&quot;::1&quot;, &quot;0.0.0.0&quot;],</span><br><span class=\"line\">    &quot;mode&quot;:&quot;tcp_and_udp&quot;,</span><br><span class=\"line\">    &quot;server_port&quot;:28388,</span><br><span class=\"line\">    &quot;local_port&quot;:1080,</span><br><span class=\"line\">    &quot;password&quot;:&quot;k58LRQwcnKqb&quot;,</span><br><span class=\"line\">    &quot;timeout&quot;:86400,</span><br><span class=\"line\">    &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;,</span><br><span class=\"line\">    &quot;plugin&quot;:&quot;ss-v2ray-plugin&quot;,</span><br><span class=\"line\">    &quot;plugin_opts&quot;:&quot;server&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>客户端安装shadowsocks与v2ray-plugin插件</p>\n<p>安装完成之后将v2ray-plug插件放入shadowsocks目录中</p>\n</li>\n</ul>\n","more":"<h1 id=\"01-网络通信的基本过程\"><a href=\"#01-网络通信的基本过程\" class=\"headerlink\" title=\"01 网络通信的基本过程\"></a>01 网络通信的基本过程</h1><p><img src=\"https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png\" alt=\"网络通信基本流程\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.png\" alt=\"网络通信原理\"></p>\n<p>我们在浏览器中输入baidu.com这个网址，我们的网络是通过ip来定位某一台服务器的，域名仅仅是一串字符串，他绑定了一个ip地址。这个ip地址是找dns服务器获取。但是一开始不是直接去找dns服务器。</p>\n<p>首先他会检查浏览器的缓存还有本地的缓存，里面有没有他的域名，如果浏览器里没有缓存就会检查本地的hosts文件，看看文件里面有没有添加映射关系。如果hosts文件里面也没有就会将请求发送到电脑配置的dns服务器上。</p>\n<ol>\n<li><p>怎么发送到dns的服务器上去的？</p>\n<p>首先要了解一下OSI的七层模型</p>\n<p>首先输入baidu.com，浏览并没有得到本地的百度ip地址，所以说他就会将请求发送到dns服务器上 </p>\n<p>dns是一个<strong>应用层</strong>的协议，<strong>它主要就是用来获取域名所绑定的ip地址</strong>，当传到应用层就会<strong>构造一个相关的协议</strong>，这个协议会生成一个相关的请求。然后，他要通过OSI模型一层一层往下传到<strong>物理层</strong>，也就是网卡的接口。生成请求数据之后，会传到<strong>传输层</strong>，他会对应用层的数据进行封装，他封装了一个源端口和目标端口，比如源端口404，目标端口，dns默认的是53号端口。然后将应用层传过来的协议和端口封装成一个<strong>数据包</strong>，然后接着往下传。<strong>传输层</strong>主要是有<strong>端口</strong>这个概念。</p>\n<p>接下来来到<strong>网络层</strong>，网络层在前面也会<strong>封装一个包头</strong>，也就是源ip和目标ip，本机的电脑ip和你要访问的服务器ip，比如本机IP192.168.1.20 和dns服务器地址8.8.8.8。将和之前的数据封装号之后发送到链路层。网络层主要会<strong>添加ip地址</strong>。网络层封装数据之后，发现目标的ip地址并不在我的网段范围之内，找不到ip地址，接下里他就会去找网关。家里的<strong>网关一般是路由器</strong>。这里就可以将请求发送给网关。在同一个局域网里面通信，使用的mac地址，数据将会来到下一层。准备发往网关数据里。</p>\n<p><strong>数据链路层</strong>会在前面加上网关的mac地址和你的源mac地址。通过ARP协议来获取到网关的cc的mac地址。</p>\n<p>接着，这条数据就会顺着<strong>物理层</strong>来到网卡的接口，他就会通过网卡从网线中发出去，来到了交换机的位置。</p>\n<p><strong>交换机他是一个二层的设备</strong>，也就是说他只能<strong>解析两层的数据</strong>。数据包从网卡来到交换机，交换机收到数据之后，看一下它里面的mac地址，源mac地址，接着，就将数据包转发到路由器mac地址为cc的这个端口。（路由器是一个三层设备，所以说它能解析三层的数据）。<strong>数据到达路由器端口之后</strong>，传到数据链路层，<strong>发现mac地址和我一样就会把它拿掉</strong>，然后就收这个数据包，接受之后就会把它的头部拿掉，拿掉之后在往上传，传到网络层，源ip地址和目标IP地址，发现没有8.8.8.8直接链接，那么路由器，它的工作就是把这个数据在路由出去，转发出去，路由器他会设置一个<strong>默认路由</strong>，当路由器发现找不到8.8.8.8的时候，他就会发送到默认路由，一般来说就直接发送到公网的其他的路由器了，于是他就会把这个数据转发给公网上的其他路由器，他会把我们的数据包从我们的WAN口（路由器中有一个颜色不一样的口，叫做WAN口，他是通往互联忘的道路），<strong>WAN口有一个公网的ip地址</strong>，也就是20.20.20.20，他需要将内网的数据转发出去，这里的话路由器还需要做一个<strong>NAT操作</strong>（网络地址转换）。因为源ip地址是一个内网的的网段，他不能在公网上进行传输，必须转成WAN口允许公网传输的这么一个协议。路由器中有一个<strong>NAT的映射表</strong>，他会先将本地的ip地址保存在在NAT映射表中，源ip地址和源端口放进去，然后将WAN公网ip地址放入网络层数据包的地址中，数据包的端口也会随便生成一个，同时也会在NAT映射表中记录一个他们之间的映射关系。之后路由器就会把数据包的ip和端口改掉，然后再回到数据链路层，然后在加上源mac地址和目标地址（<strong>注意</strong>：源mac地址就是现在的WAN口地址了，目标mac地址就是它的下一条的路由器的mac地址）。最后在来到物理层。最后他这个数据包就会从WAN口出去来到了互联网上的其他路由器，经过十来个路由器，最终找到dns服务器，然后将数据交给这台dns服务器。</p>\n<p>我们知道dns是一个应用层的协议，所以这台服务器也能解析到应用层。</p>\n<p>dns服务器拿到数据包之后，从物理层到数据链路层，解析mac地址正确，拿掉数据包的mac地址，然后在往上传这个数据包，网络层，传输层依旧如此。最后把这个报文发送给应用层的dns应用，dns收到这个请求后。生成一个dns的响应，之后就会沿着OSI模型往回传</p>\n</li>\n<li><p>补充</p>\n<p>在传输层有两个协议一个是tcp，还有一个是udp。我们在应用层这个http的话，他是基于tcp的，我们要发送http请求，必须先使用tcp的方式跟访问的谷歌服务器建立连接，才能发送http请求。</p>\n<p>现在要访问谷歌，得到正确的ip地址之后，我们要先发送一个tcp建立连接的请求 ，比如说，发送一个连接请求，来到传输层，用源端口和目标端口建立连接，一系列操作后，来到物理层发送出去，发现ip不在国内，于是会经过防火墙（GFW），经过防火墙的时候，（这个防火墙强大到可以解析应用层的流量）防火墙里有一个列表，记录了一些黑名单的ip地址或者域名之类的，或者防火墙可以伪装的谷歌服务器，给你返回数据包。（<strong>tcp重置攻击</strong>）</p>\n<p>当与服务器建立连接发送请求后，如果数据包里面有关于google 的信息，GFW也会把它干掉，虽然已经与服务器建立连接，但是数据根本就传不出去</p>\n</li>\n</ol>\n<h1 id=\"02-墙拦截的原理与绕过\"><a href=\"#02-墙拦截的原理与绕过\" class=\"headerlink\" title=\"02 墙拦截的原理与绕过\"></a>02 墙拦截的原理与绕过</h1><p>当浏览器发送一个请求，发送的谷歌服务器，当返回回来之后，GFW会在返回的ip里面动一些手脚，本地收到数据包之后，由应用层解析完毕之后，于是我们就拿到了一个假的IP地址（<strong>DNS污染 ，也可以叫dns劫持</strong>）。</p>\n<p>这个时候我们如果不发送dns请求，他就不会造成dns污染。当我们浏览器访问谷歌的一瞬间，他并不是直接发送dns，而是先检查本地的dns缓存，如果没有再去检查hosts文件。如果hosts文件中有ip和域名的映射关系，当浏览器发起的时候，而是直接找到hosts文件，应为hosts文件里面添加了映射关系，他就会直接使用这个ip，不需要在发送dns请求，去通过dns获取ip地址。</p>\n<p>经过以上集中凡是的拦截，我们的路就会被卡的死死的，我们第一时间想到的就是使用代理进行访问，我们接触最后的代理方式就是http代理和socks5代理。比如我们在vps上搭建一个socks5的服务，监听了一个端口1080，我们就可以构建一个数据包，发往这台vps6.6.6.6 端口1080，和这个端口建立连接。虽然说确实可以正常访问谷歌服务器，也没有经过防火墙，但是<strong>从我们这里发出去就不行</strong>了，比如说，我们发送到防火墙这里，众所周知，防火墙可以解析到应用层，也就是说它可以看到里面的内容， 看到想让vps这台服务器帮你解析谷歌，他又会帮你干掉了</p>\n<ol>\n<li><p>为什么可以如此精确的阻断连接？</p>\n<p>归根结底，我们的意图被它看到了，它可以解析里面的数据内容</p>\n</li>\n<li><p>怎么才能让他看不到里面的内容？</p>\n<p>加密，vpn他就是会加密数据流量的，比如我们经常使用的IPsec，或者openVpn，这些协议他都可以进行对数据加密。那么这种传统的vpn虽然可以进行对数据加密，但是他的特征会非常明显，也就是说虽然防火墙它看不到我们的数据内容，但是它能知道我们在进行vpn连接。</p>\n</li>\n<li><p>那么要怎么做才能既加密流量又没有特征呢？</p>\n<p>shadowsocks，这个协议一出生就是为了绕过防火墙的检查</p>\n<p>假设在vps上搭建一个ss的服务端，它监听一个端口8388，同时我们本机运行一个ss客户端，然后它监听一个端口1080，socks5的端口，同时我们的浏览器设置了一个代理端口，也就是说我们浏览器的访问请求会先走这个代理端口（1080），ip地址就是本机127.0.0.1，就相当于我们在浏览器中发送一个访问谷歌请求的时候，这个请求会转发到本机的1080这个端口， 那么这个端口是由ss的客户端在监听，那么这个请求就会发送到ss的客户端，客户端拿到这个请求，他会对这个请求加密，会把里面的内容加密，加密之后我们是看不到数据包里面的内容，然后就会来到传输层，那么他会从源端口是监听1080，目标端口就是客户端里面配置好的需要连接的服务器（8388），最后由物理层发送出去。防火墙放行通过后，就会路由到vps服务器，服务器拿到数据包，解析8388端口，是ss服务端处理，拿到数据之后进行解密，解密之后就会获得原始的请求，他会代替你访问谷歌，他会从谷歌得到一份响应， 收到数据后，同样也会对数据进行加密，加密之后重新构造一个数据包，返回给客户端，最后客户端会得到这个数据包，ss客户端拿到数据之后将会返回给浏览器，浏览器拿到数据之后就可以愉快的访问了。</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/%E7%BF%BB%E5%A2%99%E5%8E%9F%E7%90%86.png\" alt=\"VPS搭建原理\"></p>\n<h1 id=\"03-节点搭建\"><a href=\"#03-节点搭建\" class=\"headerlink\" title=\"03 节点搭建\"></a>03 节点搭建</h1><p><strong>vps</strong></p>\n<p><strong>虚拟专用服务器</strong>（英语：Virtual private server，缩写为VPS），是将一台<a href=\"https://zh.m.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8\">服务器</a>分割成多个虚拟专用服务器的服务。实现VPS的技术分为<a href=\"https://zh.m.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96\">容器</a>技术和<a href=\"https://zh.m.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA\">虚拟机</a>技术。在容器或虚拟机中，每个VPS都可分配独立公网<a href=\"https://zh.m.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80\">IP地址</a>、独立<a href=\"https://zh.m.wikipedia.org/zh-cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\">操作系统</a>、实现不同VPS间磁盘空间、<a href=\"https://zh.m.wikipedia.org/wiki/%E5%86%85%E5%AD%98\">内存</a>、<a href=\"https://zh.m.wikipedia.org/wiki/CPU\">CPU</a>资源、进程和系统配置的隔离，为用户和<a href=\"https://zh.m.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F\">应用程序</a>模拟出“独占”使用计算资源的体验。VPS可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。VPS为用户提供了管理配置的自由，可用于企业虚拟化，也可以用于<a href=\"https://zh.m.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83\">IDC</a>资源租用。</p>\n<ol>\n<li><p>购买vps服务器</p>\n<p>vultr ：<a href=\"https://www.vultr.com/\">https://www.vultr.com/</a></p>\n<p>第二个相对比较实惠；</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/image-20221212221930138.png\" alt=\"image-20221212221930138\"></p>\n</li>\n<li><p>在Linux下搭建shadonsocks服务端</p>\n<p>shadownsocks相关命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">安装shadowsocks</span></span><br><span class=\"line\">apt install shadowsocks-libev</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看shadowsocks状态</span></span><br><span class=\"line\">systemctl status shadowsocks-libev.service</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">编辑ss配置文件</span></span><br><span class=\"line\">vim /etc/shadowsocks-libev/config.json</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启shadowsocks</span></span><br><span class=\"line\">systemctl restart shadowsocks-libev.service</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看shadowsocks运行日志：</span></span><br><span class=\"line\">journalctl -u shadowsocks-libev.service -f</span><br></pre></td></tr></table></figure>\n\n<p>Ubuntu防火墙设置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看状态</span></span><br><span class=\"line\">ufw status</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">开放端口</span></span><br><span class=\"line\">ufw allow 8388</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">拒绝端口</span></span><br><span class=\"line\">ufw deny 8388</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">删除规则</span></span><br><span class=\"line\">ufw delete allow 8388</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">关闭防火墙</span></span><br><span class=\"line\">ufw disable</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动防火墙</span></span><br><span class=\"line\">ufw enable</span><br></pre></td></tr></table></figure></li>\n<li><p>相关命令解释</p>\n<p>vim /etc/shadowsocks-libev/config.json</p>\n<p>需要将IP地址改成0.0.0.0,改成0的意思是接受所有ip地址往他的8388端口发送数据，默认是只允许本机（127.0.0.1环回地址）的地址发送数据。</p>\n<p>密码需要一样，因为它使用的是对称加密算法，并且加密方式为GCM的格式，这种加密方式是带身份认证的</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;server&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span><span class=\"string\">&quot;::1&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;0.0.0.0&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mode&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;tcp_and_udp&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;server_port&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">8388</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;local_port&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1080</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;password&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;k58LRQwcnKqb&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;timeout&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">86400</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;method&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;chacha20-ietf-poly1305&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;server&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span><span class=\"string\">&quot;::1&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;0.0.0.0&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mode&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;tcp_and_udp&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;server_port&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">8388</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;local_port&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1080</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;password&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;h0rc6ZWBBaRI&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;timeout&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">86400</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;method&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;chacha20-ietf-poly1305&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>重放攻击</strong>：假设电脑生成一个数据包，往服务器上发，其中经过了防火墙，防火墙它也可以拿着你的数据主动往服务器上发送，用你的数据发送，这就是一个重放攻击。它的探测目的就是为了了解你这个服务器上是否运行了某些服务，比如shadowsockes。具体怎么探测到就不得而知了。</p>\n<ol start=\"4\">\n<li><p>相关连接</p>\n<p>SSH连接工具（FinalShell）：<a href=\"https://bulianglin.com/g/aHR0cDovL3d3dy5ob3N0YnVmLmNvbS90Lzk4OC5odG1s\">http://www.hostbuf.com/t/988.html</a><br>SS客户端(shadowsocks-windows)： <a href=\"https://bulianglin.com/g/aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzL3NoYWRvd3NvY2tzLXdpbmRvd3M\">https://github.com/shadowsocks/shadowsocks-windows</a><br>shadowsocks插件(v2ray-plugin)：<a href=\"https://bulianglin.com/g/aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzL3YycmF5LXBsdWdpbg\">https://github.com/shadowsocks/v2ray-plugin</a><br>方便测速但不支持ss插件(v2rayN)：<a href=\"https://bulianglin.com/g/aHR0cHM6Ly9naXRodWIuY29tLzJkdXN0L3YycmF5Tg\">https://github.com/2dust/v2rayN</a></p>\n</li>\n<li><p>Tcpping测试连接显示timeout，也就是没办法和vps进行通讯，这是为什么呢？</p>\n<p>因为服务器上的防火墙没有关，在服务器的外围，其实还有一层防火墙，刚安装好只开放了一个22号端口，也就是说我们从外面往它里面发送数据，他只允许访问22号端口，8388端口是不允许访问的。</p>\n</li>\n</ol>\n<p>在外面发送请求的时候，防火墙马上发送了一个探测包，这个防火墙拿这我们的数据，他也主动往服务器发送了一次，然后我们服务器显示认证失败，但是这个防火墙已经得到了它想要的。他可能在这一次探测当中，就已经知道了你这里已经运行了shadowsocks的服务，虽然说他可能防重放攻击，但是防火墙已经达到的探测目的，当他已经知道你这里运行了shadowsocks的服务的时候，他就会把你们的连接切断。</p>\n<p>既然能被探测那么ss节点是不是没办法用了？理论上来说确实是，但是ss协议引入了plagin功能，它主要的功能就是对数据流量进行伪装，比如说把我们经过ss假币后的数据流量伪装成普通的http或者websocket这种协议的流量。</p>\n<p>首先浏览器会构建一个请求，由于我们设置了系统代理，所以说他会把这个请求发送到配置的系统代理，也就是1080端口，这个数据就会来到ss客户端，因为它监听了客户端，会使用ss客户端的加密方式和密码对请求进行加密，如果没有插件就会直接传到防火墙，但是加了插件，会传到插件这里，他会对这个数据流量进行伪装（比如会伪装成http协议头的头），让防火墙以为我们在访问一个正常的网站，当防火墙发现他只是一个普通的http流量的时候，就可能不会再向服务器发送探测包了。于是数据包就会放行通过，当来到vps时，插件拿到数据的时候会把协议头去掉，之后就把真正的数据发往服务端了。这就是plagin的原理，主要起到了流量伪装的作用。</p>\n<p>ssr节点就是类似加了插件的ss节点</p>\n<ul>\n<li>服务端安装plugin插件</li>\n</ul>\n<p><code>apt install shadowsocks-v2ray-plugin  </code></p>\n<p>修改配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:[&quot;::1&quot;, &quot;0.0.0.0&quot;],</span><br><span class=\"line\">    &quot;mode&quot;:&quot;tcp_and_udp&quot;,</span><br><span class=\"line\">    &quot;server_port&quot;:28388,</span><br><span class=\"line\">    &quot;local_port&quot;:1080,</span><br><span class=\"line\">    &quot;password&quot;:&quot;k58LRQwcnKqb&quot;,</span><br><span class=\"line\">    &quot;timeout&quot;:86400,</span><br><span class=\"line\">    &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;,</span><br><span class=\"line\">    &quot;plugin&quot;:&quot;ss-v2ray-plugin&quot;,</span><br><span class=\"line\">    &quot;plugin_opts&quot;:&quot;server&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>客户端安装shadowsocks与v2ray-plugin插件</p>\n<p>安装完成之后将v2ray-plug插件放入shadowsocks目录中</p>\n</li>\n</ul>\n","categories":[{"name":"网络通信","path":"api/categories/网络通信.json"}],"tags":[{"name":"VPS","path":"api/tags/VPS.json"}]}