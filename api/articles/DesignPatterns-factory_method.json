{"title":"工厂模式","slug":"DesignPatterns-factory_method","date":"2022-12-20T16:00:00.000Z","updated":"2024-12-03T07:22:26.000Z","comments":true,"path":"api/articles/DesignPatterns-factory_method.json","excerpt":null,"covers":["https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/FactoryMethod.jpg"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>工厂方法模式包含如下角色：</p>\n<ul>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/FactoryMethod.jpg\" alt=\"FactoryMethod\"></p>\n<p>代码示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抽象工厂</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Factory</span>()&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteFactory</span> : <span class=\"keyword\">public</span> Factory</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ConcreteFactory</span>()&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\">Product* <span class=\"title\">createProduct</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> <span class=\"built_in\">ConcreteProduct</span>();&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Factory* f  = <span class=\"keyword\">new</span> <span class=\"built_in\">ConcreteFactory</span>();</span><br><span class=\"line\">    Product* p = f-&gt;<span class=\"built_in\">createProduct</span>()</span><br><span class=\"line\">    p-&gt;<span class=\"built_in\">use</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">delete</span> f;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>\n<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>\n<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>\n<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>\n</ul>\n<p>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</p>\n<p>参考资料：<a href=\"https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html\">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html</a></p>\n","more":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>工厂方法模式包含如下角色：</p>\n<ul>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MearcDada/FigureBed//blog/FactoryMethod.jpg\" alt=\"FactoryMethod\"></p>\n<p>代码示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抽象工厂</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Factory</span>()&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteFactory</span> : <span class=\"keyword\">public</span> Factory</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ConcreteFactory</span>()&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\">Product* <span class=\"title\">createProduct</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> <span class=\"built_in\">ConcreteProduct</span>();&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Factory* f  = <span class=\"keyword\">new</span> <span class=\"built_in\">ConcreteFactory</span>();</span><br><span class=\"line\">    Product* p = f-&gt;<span class=\"built_in\">createProduct</span>()</span><br><span class=\"line\">    p-&gt;<span class=\"built_in\">use</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">delete</span> f;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>\n<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>\n<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>\n<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>\n</ul>\n<p>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</p>\n<p>参考资料：<a href=\"https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html\">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html</a></p>\n","categories":[{"name":"设计模式","path":"api/categories/设计模式.json"}],"tags":[{"name":"C++","path":"api/tags/C++.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}